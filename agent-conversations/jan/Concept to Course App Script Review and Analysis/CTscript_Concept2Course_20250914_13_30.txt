/**
 * Concept‑to‑Course — created by Carla Taylor t/as Carlorbiz 20250830-06-55, enhanced 20250914_13-30
 * Script Properties in place: GEMINI_API_KEY, DRIVE_FOLDER_ID, SLIDES_TEMPLATE_ID
 */

// ==== A) Config & Brand ====

const CFG = {
  get GEMINI_API_KEY() {
    const v = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
    if (!v) throw new Error('Set GEMINI_API_KEY in Script Properties.');
    return v;
  },
  get DRIVE_FOLDER_ID() {
    const v = PropertiesService.getScriptProperties().getProperty('DRIVE_FOLDER_ID');
    if (!v) throw new Error('Set DRIVE_FOLDER_ID in Script Properties.');
    return v;
  },
  get SLIDES_TEMPLATE_ID() {
    const v = PropertiesService.getScriptProperties().getProperty('SLIDES_TEMPLATE_ID');
    if (!v) throw new Error('Set SLIDES_TEMPLATE_ID in Script Properties.');
    return v;
  },
  AU_PROMPT: 'Use Australian English and professional healthcare tone suitable for CPD. Prefer Australian guidelines and RACGP where relevant.',
  BRAND_HEADER: [
    'You are writing on behalf of GPSA / HPSA — the peak Australasian authority on best-practice supervision of medical learners and the healthcare workforce.',
    'Use Australian English (en-AU) and a practical, supportive, non-judgemental tone consistent with GPSA/HPSA.',
    'Anchor content in general practice / primary care contexts including rural and remote settings.',
    'Emphasise safe, effective supervision; coaching; feedback; assessment for learning; psychological safety.',
    'Respect cultural safety, including Aboriginal and Torres Strait Islander health; avoid stereotypes and patient-identifiable data.',
    'Prefer RACGP, ACRRM and AHPRA-aligned terminology and concepts; do not fabricate citations or guideline numbers.',
    'Terminology preferences: "general practice", "supervisor", "registrar", "learner", "clinical supervision", "CPD". Avoid US spellings.',
    'Outputs must be original and tailored for GPSA/HPSA; avoid generic boilerplate.'
  ].join('\n'),
  TTS_WPM: 150,

  // Enhanced configuration validation
  validateConfiguration() {
    const required = ['GEMINI_API_KEY', 'DRIVE_FOLDER_ID', 'SLIDES_TEMPLATE_ID'];
    const missing = required.filter(key => {
      try { return !this[key]; } catch (e) { return true; }
    });
    if (missing.length > 0) {
      throw new Error(`Configuration incomplete. Please set in Script Properties: ${missing.join(', ')}`);
    }
    // Test Drive folder access
    try { DriveApp.getFolderById(this.DRIVE_FOLDER_ID).getName(); } 
    catch (e) { throw new Error('Cannot access Drive folder. Check DRIVE_FOLDER_ID.'); }
    // Test template access
    try { DriveApp.getFileById(this.SLIDES_TEMPLATE_ID).getName(); } 
    catch (e) { throw new Error('Cannot access slides template. Check SLIDES_TEMPLATE_ID.'); }
    return true;
  },

  // Track API usage to prevent quota exhaustion
  trackApiUsage(endpoint, tokens = 0) {
    const props = PropertiesService.getScriptProperties();
    const today = new Date().toDateString();
    const key = `usage_${endpoint}_${today}`;
    const current = parseInt(props.getProperty(key) || '0');
    props.setProperty(key, String(current + tokens));
    if (endpoint === 'gemini' && current > 800000) {
      console.warn('Approaching Gemini API daily quota limit');
    }
  },

  // Configurable batch processing settings
  getBatchSize() {
    const customSize = PropertiesService.getScriptProperties().getProperty('BATCH_SIZE');
    return customSize ? parseInt(customSize) : 3; // Default to 3 modules per batch
  },

  setBatchSize(size) {
    PropertiesService.getScriptProperties().setProperty('BATCH_SIZE', String(size));
  }
};

function brandHeader_(){ return CFG.BRAND_HEADER + '\n\n' + CFG.AU_PROMPT + '\n'; }

function brandHeaderWithCitations_() { 
  return CFG.BRAND_HEADER + '\n\n' + CFG.AU_PROMPT + '\n\n' + `
VANCOUVER CITATION REQUIREMENTS:
When referencing clinical evidence, guidelines, or research:
- Use numerical citations in square brackets: [1], [2], [3]
- Multiple sources: [1,3,5] or consecutive: [2–4]
- Include reference list at end when appropriate
- Use proper journal abbreviations (N Engl J Med, BMJ, Med J Aust, etc.)
- Format: Author(s). Title. Journal. Year;Volume(Issue):Pages.
- For guidelines: Organisation. Title. Place: Publisher; Year.
- Prefer authoritative Australian sources: RACGP, ACRRM, AHPRA, Medical Board of Australia
- Only cite real, verifiable sources - never fabricate citations
` + '\n';
}

const VANCOUVER_CITATION_INSTRUCTIONS = `
CITATIONS & REFERENCES (MANDATORY):
- Use numeric in-text citations like [1], [2] at the end of the relevant sentence(s).
- At the end of the document, include a "References" section using Vancouver style.
- Vancouver formatting guidance:
  • Journal article: Surname Initials. Title. Journal. Year;Volume(Issue):Pages.
  • Web page: Surname/Org. Title [Internet]. Publisher; Year [cited YEAR MONTH DAY]. Available from: URL
  • Report/Doc: Author/Org. Title. Place: Publisher; Year. Available from: URL
- Only cite items provided in the source pack; do not fabricate references.
- Keep references concise but complete enough to identify the source.
`;

// -- AU English normalisation utility --
function au(txt) {
  if (!txt) return txt;
  let t = String(txt);
  t = t.replace(/\borganize(d|s|r|)\b/gi, m => m.replace('ize','ise').replace('ized','ised').replace('izes','ises'));
  t = t.replace(/\borganization(s)?\b/gi,'organisation$1');
  t = t.replace(/\banalyz(e|ed|ing|es)\b/gi, m => m.replace('yze','yse'));
  t = t.replace(/\bbehavior(s)?\b/gi,'behaviour$1');
  t = t.replace(/\bcolor(s|ed|ing)?\b/gi,'colour$1');
  t = t.replace(/\bcenter(s|ed|ing)?\b/gi,'centre$1');
  t = t.replace(/\bmodeling\b/gi,'modelling');
  return t;
}

// -- TTS voice setting function for TTS tab --
function setTtsVoice_() {
    const ui = SpreadsheetApp.getUi();
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
    if (!sheet.getName().startsWith('TTS-')) {
        ui.alert('This function can only be run from a TTS sheet.');
        return;
    }
    const range = sheet.getActiveRange();
    if (!range || range.getNumRows() === 0) {
        ui.alert('Please select one or more rows to apply the voice change.');
        return;
    }
    const voices = [
        { name: "Schedar (Female, Even, Professional)", value: "Schedar" },
        { name: "Vindemiatrix (Female, Gentle)", value: "Vindemiatrix" },
        { name: "Gacrux (Female, Mature)", value: "Gacrux" },
        { name: "Puck (Male, Upbeat, Engaging)", value: "Puck" },
        { name: "Charon (Male, Informative, Deep)", value: "Charon" },
        { name: "Orus (Male, Firm, Authoritative)", value: "Orus" },
    ];
    const promptMessage = 'Enter the primary name of the voice to apply (e.g., Schedar, Puck, Charon).\n\nAvailable Voices:\n' + voices.map(v => `- ${v.name}`).join('\n');
    const choice = ui.prompt('Set TTS Voice', promptMessage, ui.ButtonSet.OK_CANCEL);
    if (choice.getSelectedButton() === ui.Button.OK) {
        const responseText = choice.getResponseText().trim().toLowerCase();
        const selectedVoice = voices.find(v => v.value.toLowerCase() === responseText || v.name.toLowerCase().includes(responseText));
        if (selectedVoice) {
            const voiceColumn = 9; // Column I on the TTS- sheet
            sheet.getRange(range.getRow(), voiceColumn, range.getNumRows(), 1).setValue(selectedVoice.value);
            SpreadsheetApp.getActiveSpreadsheet().toast(`Voice set to "${selectedVoice.name}" for ${range.getNumRows()} rows.`);
        } else {
          ui.alert(`Voice "${responseText}" not found. Please type one of the main names like 'Schedar', 'Puck', or 'Charon'.`);
        }
    }
}

// ==== Inline-URL crawl controls (safe defaults) ====
const URL_CRAWL_LIMIT = 12;        // max number of distinct URLs to fetch
const URL_CRAWL_TIMEOUT_MS = 20000; // per-request timeout (ms)
const URL_MAX_APPEND_CHARS = 20000; // cap text added from crawled pages

// ==== B) Custom Prompts & API ====

// ---- Enhanced Prompt Constants ----
const COURSE_MAPPING_PROMPT = `You are an expert course designer for Australian healthcare education. Analyze the provided concept and source materials to create a comprehensive course structure with detailed justification.

AUDIENCE CONTEXT:
- Clinical: Clinical supervisors, practicing clinicians in supervisory roles
- Combined: Both clinical and administrative perspectives  
- Administrative: Healthcare administrators, non-clinical staff, system managers
- Other: General healthcare education support roles

REQUIREMENTS:
1. Analyze the concept and justify why it should be broken into separate modules
2. Recommend 8-12 modules based on content depth and audience needs
3. Each module should be substantial enough for 45-60 minutes of learning as a standalone topic
4. Ensure logical progression and skill building
5. Include practical, workplace-applicable content
6. Consider Australian healthcare context and regulations
7. Explain how modules combine to form a high-quality micro-credentialing course

OUTPUT FORMAT:
COURSE RECOMMENDATION:
[6 paragraph detailed recommendation explaining:]
- Why this concept warrants a structured course approach
- How breaking it into modules enhances learning effectiveness
- Why this specific module breakdown serves the audience effectively
- How modules build upon each other progressively
- Target audience fit and learning progression
- Value as a micro-credentialing opportunity

RECOMMENDED MODULES:
1. [Module Name] - [Detailed description with learning focus and practical applications]
2. [Module Name] - [Detailed description with learning focus and practical applications]
[Continue for all recommended modules - up to 12 for comprehensive courses]

COURSE STRUCTURE RATIONALE:
[500 words for each separate module explaining:]
- Educational value of this module in the context of the course topic and relevance to the audience 
- Integration points and practical application opportunities
- Assessment and credentialing considerations

MICRO-CREDENTIALING VALUE:
[Explanation of how this course structure provides valuable professional development and recognition]`;

const RESEARCH_ENHANCEMENT_PROMPT = `You are a research specialist for Australian healthcare education. Enhance the provided source materials by identifying additional high-quality resources.

REQUIREMENTS:
1. Find 5-8 additional peer-reviewed articles or industry resources
2. Focus on Australian healthcare context where possible
3. Include recent publications (published since 2021)
4. Ensure sources are accessible and credible
5. Provide 2-3 sentences summarising the relevance of each source material added through your research
6. Create single comprehensive list of References using Chicago-Style Citation

SOURCE MATERIALS PROVIDED:
[EXISTING_SOURCES]

OUTPUT FORMAT:
ADDITIONAL RECOMMENDED SOURCES:

1. [Title] - [Author/Organization] ([Year])
   URL: [if available]
   Relevance: [2-3 sentences explaining why this source enhances the course]

2. [Continue pattern...]

RESEARCH SUMMARY:
[2-3 sentences summarizing how these additional sources strengthen the course development]`;

const ENHANCED_SCENARIOS_CONTENT = `
**INTERACTIVE SCENARIO DEVELOPMENT - Australian Healthcare Supervision**

**Target Audience**: Clinical supervisors and non-clinical staff supporting medical learners in Australian healthcare placements
**Delivery Platform**: iSpring Role Plays (SCORM 2004 compatible for Absorb LMS)

**SCENARIO REQUIREMENTS**:
- Australian healthcare environment (public hospitals, community health, GP clinics, aged care)
- Diverse, multicultural teams reflecting contemporary Australian healthcare workforce
- Real-world supervision challenges faced by clinical and non-clinical staff
- Contemporary placement coordination scenarios with authentic complexity

**Character Development**:
- Include Aboriginal and Torres Strait Islander, multicultural backgrounds authentically
- Specify roles: nurse, allied health, admin coordinator
- Diverse team members, patients, family members as contextually appropriate

**Branching Dialogue Structure** (3 decision points minimum):
1. Initial response to supervision challenge
2. Escalation or follow-up management  
3. Resolution and learning integration

Generate 2-3 comprehensive interactive scenarios with complete dialogue scripts, character profiles, and learning objectives.`;

const ENHANCED_ASSESSMENTS_CONTENT = `
**COMPREHENSIVE ASSESSMENT DEVELOPMENT - Australian Healthcare Supervision Training**

**Assessment Design Principles**:
- Knowledge Application: Test practical understanding, not rote memorization
- Cultural Competency: Include scenarios requiring inclusive, culturally safe approaches
- Professional Judgment: Evaluate decision-making in complex supervision situations
- Evidence-Based Practice: Assess integration of contemporary research and best practices

**Assessment Type Distribution**:
- Multiple Choice Questions (40%): Scenario-based, real Australian healthcare supervision situations
- True/False with Rationale (20%): Professional standards, best practices, cultural safety
- Drag-and-Drop Interactive (20%): Process sequencing, priority ranking, resource matching
- Scenario Reflection Questions (20%): Complex supervision situations requiring written responses

**Quality Standards**: Evidence-based rationales, Australian healthcare context, inclusive design, professional credibility... Generate comprehensive assessment battery (15-20 questions) with detailed rationales and learning objective alignment.`;

const ENHANCED_DOWNLOADABLES_CONTENT = `
**PROFESSIONAL DOWNLOADABLE RESOURCE DEVELOPMENT - Australian Healthcare Supervision**

**Resource Type**: Comprehensive PDF supplement (1500-2500 words)
**Purpose**: Extend module learning with practical implementation tools and evidence-based frameworks

**Content Architecture**:
- Executive Summary (200-300 words): Module integration, practical value, evidence foundation
- Theoretical Foundation (400-500 words): Evidence-based framework, Australian healthcare context, cultural competency
- Practical Implementation Guide (600-800 words): Step-by-step procedures, real-world applications, team integration
- Tools and Templates (300-400 words): Assessment frameworks, communication templates, escalation procedures
- Case Study Applications (400-500 words): Diverse scenarios, cultural considerations, problem-solving examples

**Quality Standards**: Evidence-based content, practical applicability, Australian healthcare alignment, adult learning principles

Generate comprehensive downloadable resource with immediate workplace implementation focus.`;

// ---- Enhanced API Rate Limiting & Error Handling ----
const API_RATE_LIMITS = {
  GEMINI: { requestsPerMinute: 10, tokensPerDay: 1000000 },
  MINIMUM_DELAY: 6000, // 6 seconds between requests
  RETRY_DELAYS: [2000, 5000, 10000] // Progressive backoff
};

// ---- Core API Helpers with Advanced Features ----
/**
 * Text-to-speech via your configured TTS backend.
 * Returns a Google Apps Script Blob (audio/wav).
 *
 * @param {string} text - Full prompt + script (we pass AUSTRALIAN_PROMPT + ' ' + script)
 * @param {string} voiceName - e.g. VOICE_NAME
 * @param {number} temperature - e.g. SPEECH_TEMPERATURE
 */
function callGeminiTTS_(text, voiceName, temperature) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('GEMINI_API_KEY');
  if (!apiKey) throw new Error('GEMINI_API_KEY not set in Script Properties.');

  // Adjust endpoint/payload to match your actual TTS provider.
  // This template uses Google Cloud TTS style; if you’re using a different provider,
  // map voice/temperature and request/response handling accordingly.
  const url = 'https://texttospeech.googleapis.com/v1/text:synthesize?key=' + encodeURIComponent(apiKey);
  const payload = {
    input: { text: String(text || '').slice(0, 5000) }, // guard length
    voice: { languageCode: 'en-AU', name: String(voiceName || 'en-AU-Neural2-A') },
    audioConfig: { audioEncoding: 'LINEAR16', speakingRate: 1.0, pitch: 0.0, effectsProfileId: ['small-bluetooth-speaker-class-device'] },
  };

  // Map temperature into a mild prosody randomness knob if your TTS supports it.
  // Cloud TTS does not have "temperature", but you can optionally map to speakingRate/pitch variability.

  const resp = UrlFetchApp.fetch(url, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true,
  });

  if (resp.getResponseCode() !== 200) {
    throw new Error('TTS HTTP ' + resp.getResponseCode() + ': ' + resp.getContentText().slice(0, 400));
  }

  const data = JSON.parse(resp.getContentText());
  const b64 = data && data.audioContent;
  if (!b64) throw new Error('TTS response missing audioContent.');

  const bytes = Utilities.base64Decode(b64);
  return Utilities.newBlob(bytes, 'audio/wav', 'tts.wav');
}


function callGeminiWithRetry(prompt, maxTokens = 8192, retries = 3, temperature = 0.7) {
  CFG.validateConfiguration();
  
  // Enhanced rate limiting with usage tracking
  const lastCall = PropertiesService.getScriptProperties().getProperty('LAST_GEMINI_CALL');
  if (lastCall) {
    const elapsed = Date.now() - parseInt(lastCall);
    const minDelay = API_RATE_LIMITS.MINIMUM_DELAY;
    if (elapsed < minDelay) {
      const waitTime = minDelay - elapsed;
      console.log(`Rate limiting: waiting ${waitTime}ms`);
      Utilities.sleep(waitTime);
    }
  }
  PropertiesService.getScriptProperties().setProperty('LAST_GEMINI_CALL', String(Date.now()));
  
  // Track daily usage
  const today = new Date().toDateString();
  const usageKey = `gemini_tokens_${today}`;
  const currentUsage = parseInt(PropertiesService.getScriptProperties().getProperty(usageKey) || '0');
  
  if (currentUsage > API_RATE_LIMITS.GEMINI.tokensPerDay * 0.9) {
    console.warn('Approaching Gemini API daily quota limit');
  }
  
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const result = callGemini(prompt, maxTokens, temperature);
      
      // Track token usage (estimate)
      const estimatedTokens = Math.ceil((prompt.length + result.length) / 3);
      PropertiesService.getScriptProperties().setProperty(usageKey, String(currentUsage + estimatedTokens));
      
      return result;
    } catch (error) {
      console.warn(`Gemini API attempt ${attempt}/${retries} failed: ${error.message}`);
      if (attempt === retries) {
        throw new Error(`Gemini API failed after ${retries} attempts: ${error.message}`);
      }
      
      // Progressive backoff with jitter
      const baseDelay = API_RATE_LIMITS.RETRY_DELAYS[attempt - 1] || 10000;
      const jitter = Math.random() * 2000; // 0-2 seconds jitter
      Utilities.sleep(baseDelay + jitter);
    }
  }
}

function callGemini(prompt, maxTokens = 8192, temperature = 0.7) {
  const body = {
    contents: [{ parts: [{ text: prompt }]}],
    generationConfig: { 
      temperature: temperature, 
      topK: 40, 
      topP: 0.95, 
      maxOutputTokens: maxTokens 
    }
  };
  
  const resp = UrlFetchApp.fetch(
    'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=' + CFG.GEMINI_API_KEY,
    { 
      method: 'post', 
      contentType: 'application/json', 
      payload: JSON.stringify(body), 
      muteHttpExceptions: true,
      timeout: 60000 // 60 second timeout
    }
  );
  
  if (resp.getResponseCode() !== 200) {
    throw new Error('Gemini API error: ' + resp.getContentText());
  }
  
  const data = JSON.parse(resp.getContentText());
  const text = data?.candidates?.[0]?.content?.parts?.map(p => p.text).join('\n') || '';
  
  if (!text.trim()) {
    throw new Error('Empty response from Gemini API');
  }
  
  return text.trim();
}

function callGeminiApi_(prompt, temperature = 0.5, useSearch = false, maxTokens = 8192) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${CFG.GEMINI_API_KEY}`;
  
  const payload = {
    "contents": [{"parts": [{"text": prompt}]}],
    "generationConfig": {
      "temperature": temperature, 
      "maxOutputTokens": maxTokens,
      "topK": 40,
      "topP": 0.95
    }
  };

  // Enhanced search capabilities
  if (useSearch) {
    payload.tools = [{"google_search_retrieval": {}}];
  }

  const options = {
    'method': 'post',
    'contentType': 'application/json',
    'payload': JSON.stringify(payload),
    'muteHttpExceptions': true,
    'timeout': 60000
  };
  
  const response = UrlFetchApp.fetch(url, options);
  const responseData = JSON.parse(response.getContentText());
  
  if (response.getResponseCode() === 200 && responseData.candidates && responseData.candidates[0].content.parts[0].text) {
    return responseData.candidates[0].content.parts[0].text.trim();
  } else {
    Logger.log("Gemini API Error: " + response.getContentText());
    throw new Error("Invalid or empty response from Gemini API. Check the execution logs for details.");
  }
}

/**
 * Gemini 2.5 Flash TTS (Generative Language API) → Blob (WAV).
 * Default voice/temperature come from your constants.
 * Callers should pass AUSTRALIAN_PROMPT + script as `text`.
 */
function callGeminiTTS_(text, voiceName, temperature) {
  // Defaults from your constants; no hard-coding
  voiceName   = (voiceName !== undefined && voiceName !== null && String(voiceName).trim() !== '')
                ? String(voiceName) : VOICE_NAME;              // e.g. 'Schedar' via your constant
  temperature = (typeof temperature === 'number')
                ? temperature : SPEECH_TEMPERATURE;            // e.g. 0.5 via your constant

  const model  = 'gemini-2.5-flash-preview-tts';
  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${CFG.GEMINI_API_KEY}`;

  const payload = {
    contents: [{ parts: [{ text: String(text || '') }]}],
    generationConfig: {
      temperature: temperature,
      responseModalities: ["AUDIO"],          // keep your current schema
      responseMimeType: "audio/wav",          // ask for WAV when possible
      speechConfig: {
        voiceConfig: {
          prebuiltVoiceConfig: { voiceName: voiceName }
        }
      }
    }
  };

  const resp = UrlFetchApp.fetch(apiUrl, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true,
    timeout: 120000
  });

  if (resp.getResponseCode() !== 200) {
    throw new Error('Gemini TTS error: ' + resp.getContentText());
  }

  const data = JSON.parse(resp.getContentText());
  const part = data?.candidates?.[0]?.content?.parts?.find(p => p.inlineData && p.inlineData.data);
  if (!part) throw new Error('No audio data in TTS response');

  const mime  = String(part.inlineData.mimeType || '').toLowerCase();
  const bytes = Utilities.base64Decode(part.inlineData.data);

  // If WAV was returned, use it; otherwise wrap PCM/L16 as WAV
  if (mime.includes('wav')) {
    return Utilities.newBlob(bytes, 'audio/wav', 'voiceover.wav');
  } else {
    // Your helper already accepts (bytes, mime) -> wavBytes
    const wavBytes = convertL16ToWav_(bytes, mime || "audio/L16;codec=pcm;rate=24000");
    return Utilities.newBlob(wavBytes, 'audio/wav', 'voiceover.wav');
  }
}

/** Back-compat shim: keep function name alive but delegate to the canonical one. */
function textToSpeech_(text, voiceName, temperature) {
  return callGeminiTTS_(text, voiceName, temperature);
}

// ---- Audio Processing Utility ----
function convertL16ToWav_(bytes, mimeType) {
  // Enhanced WAV conversion with proper header
  const sampleRate = 24000;
  const numChannels = 1;
  const bitsPerSample = 16;
  const dataSize = bytes.length;
  const fileSize = 36 + dataSize;
  
  const header = new Uint8Array(44);
  const view = new DataView(header.buffer);
  
  // RIFF header
  view.setUint32(0, 0x46464952, true); // "RIFF"
  view.setUint32(4, fileSize, true);
  view.setUint32(8, 0x45564157, true); // "WAVE"
  
  // Format chunk
  view.setUint32(12, 0x20746D66, true); // "fmt "
  view.setUint32(16, 16, true); // chunk size
  view.setUint16(20, 1, true); // PCM format
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true); // byte rate
  view.setUint16(32, numChannels * bitsPerSample / 8, true); // block align
  view.setUint16(34, bitsPerSample, true);
  
  // Data chunk
  view.setUint32(36, 0x61746164, true); // "data"
  view.setUint32(40, dataSize, true);
  
  // Combine header with audio data
  const wavData = new Uint8Array(header.length + bytes.length);
  wavData.set(header);
  wavData.set(bytes, header.length);
  
  return wavData;
}

// ---- Enhanced Prompt Builders ----
function buildCourseRecommendationPrompt_(conceptName, targetAudience, sourceContext = '') {
  return brandHeader_() + `You are an expert curriculum designer for Continuing Professional Development (CPD) in the Australian healthcare sector.

Based on the following course details, generate a logical and comprehensive list of 10-12 module titles.

**Course Concept:** "${conceptName}"
**Target Audience:** "${targetAudience}"
${sourceContext ? `**Context from Source Materials:** "${sourceContext.slice(0, 500)}..."` : ''}

**Instructions:**
1. Brainstorm a list of essential topics that would form a complete course on the concept.
2. Structure these topics into a logical learning pathway.
3. Each module title should be clear, descriptive, and engaging.
4. Consider progression from foundational to advanced concepts.
5. Ensure practical applicability for the target audience.
6. Return ONLY the list of 10-12 module titles, each on a new line. Do not include numbers or bullet points.`;
}

function buildModuleDescriptionPrompt(moduleName, concept, targetAudience = 'Clinical') {
  return brandHeader_() + `Generate a detailed, engaging module description (approx 180-220 words) for an online CPD course for Australian healthcare professionals.

Course Concept: "${concept}"
Module Name: "${moduleName}"
Target Audience: "${targetAudience}"

The description must:
- State the module's purpose and learning outcomes
- Outline key challenges and learning opportunities
- Emphasise practical skills aligned with RACGP/ACRRM standards
- Include specific workplace applications
- Reference contemporary Australian healthcare context
- Use engaging, professional language that motivates learning

Return only the description.`;
}

function buildKeyConceptsPrompt(description, moduleName, concept) {
  return brandHeader_() + `Based on the module description, identify and list 5-7 key concepts that must be covered. For each concept, provide a comprehensive one-sentence summary that captures both the theoretical foundation and practical application.

Module: "${moduleName}"
Course Concept: "${concept}"
Description: ${description}

Format as a numbered list with detailed explanations. Return only the list.`;
}

function buildSlideSpecsPrompt(description, concepts, moduleName, concept) {
  return brandHeader_() + `Create a comprehensive 12-slide specification for the module "${moduleName}". Structure as follows:
- Slide 1: Introduction and learning objectives
- Slides 2-10: Core content covering key concepts
- Slide 11: Integration and practical application
- Slide 12: Summary and next steps

For each slide, provide:
- A clear, engaging title
- 4-5 detailed content bullet points
- Logical flow and progression

Module Description: ${description}
Key Concepts: ${concepts}

Format each slide as "# Slide [Number]: [Title]" followed by bullet points. Return only the 12 slide specifications.`;
}

function buildEnhancedAssessmentsPrompt_(moduleName, moduleDescription, slideSpecs) {
  return brandHeader_() + `You are an experienced educator creating comprehensive assessments for an iSpring Suite Max course for Australian healthcare professionals. 

Develop a sophisticated assessment battery (6-8 questions total) based on the module details provided.

**MODULE DETAILS:**
* **Module Name:** ${moduleName}
* **Module Description:** ${moduleDescription}
* **Slide Content Outline:** ${slideSpecs}

**TASK:** Create a diverse mix of assessment types that test higher-order thinking:
- Scenario-Based MCQs (40%): Complex, multi-layered situations
- True/False with Detailed Justification (25%): Professional standards and ethics
- Matching/Drag-and-Drop Activities (20%): Process sequencing, priority ranking
- Short Answer Reflection Questions (15%): Critical thinking and application

**QUALITY STANDARDS:** 
- Test practical application and professional judgment
- Include cultural safety considerations
- Reference Australian healthcare standards
- Provide comprehensive rationales for all options

**OUTPUT FORMAT (Use Markdown):**
For each item, provide:
### Assessment [Number]: [Question Type]
**Scenario/Context:** [If applicable]
**Question Stem:** ...
**Options:** [For MCQs and matching]
**Correct Answer:** ...
**Comprehensive Rationale:**
- **Correct:** [Detailed explanation with reasoning]
- **Incorrect Options:** [Explanation for each distractor]
- **Learning Objective Alignment:** [Which slide/concept this assesses]

Return only the complete assessment battery in the specified format.`;
}

function buildEnhancedScenariosPrompt_(moduleName, moduleDescription, slideSpecs) {
  return brandHeader_() + `You are an expert instructional designer creating immersive role-play scenarios for an iSpring Suite course for Australian healthcare professionals.

**MODULE DETAILS:**
* **Module Name:** ${moduleName}
* **Module Description:** ${moduleDescription}
* **Slide Content Outline:** ${slideSpecs}

**TASK:** Create TWO detailed, branching role-play scenarios with realistic dialogue, meaningful choices, and immediate feedback.

**SCENARIO REQUIREMENTS:**
- Authentic Australian healthcare contexts
- Diverse, culturally appropriate character representation
- Multiple decision points with consequences
- Realistic dialogue and professional language
- Clear learning objectives alignment

**OUTPUT FORMAT (Use Markdown):**

## Scenario 1: [Title]
### Learning Objectives
### Character Profiles
**Primary Character:** [Name, role, background]
**Supporting Characters:** [Names, roles, relationships]

### Scene Setup
### Branching Dialogue Tree
**Initial Situation:** [Context setting]
- **Character says:** "..."
- **Learner's Choice A:** "..." → **Outcome:** [Consequence and feedback]
- **Learner's Choice B:** "..." → **Outcome:** [Consequence and feedback]
- **Learner's Choice C:** "..." → **Outcome:** [Consequence and feedback]

**Follow-up Decisions:** [Continue pattern]

### Debriefing Points
### Assessment Integration

## Scenario 2: [Title]
[Follow same structure]

Return only the detailed scenarios in the specified format.`;
}

function buildDownloadablePrompt(slideSpecs, moduleName, concept) {
  return brandHeader_() + `Generate COMPLETE and FINAL text for two comprehensive downloadable resources based on the module "${moduleName}". You must conduct research and write full content.

**CRITICAL INSTRUCTIONS:**
- NO placeholders - generate actual content
- MUST use search tools for real, verifiable sources
- Provide complete, ready-to-use resources

---

**Resource 1: Executive Quick Reference Guide (800 words)**
Create a comprehensive summary covering:
1. **Executive Summary** (150 words): Key takeaways and strategic value
2. **Core Principles** (300 words): Essential concepts with practical context
3. **Implementation Checklist** (200 words): Step-by-step action items
4. **Troubleshooting Guide** (150 words): Common challenges and solutions

Based on: ${slideSpecs.slice(0, 2000)}

---

**Resource 2: Evidence-Based Extended Learning (1200 words)**
Generate an expanded resource including:

**1. Advanced Case Studies (400 words):**
Create 3 detailed, anonymised case studies reflecting real-world challenges related to "${moduleName}". Each should be 120-150 words with:
- Realistic scenario setup
- Key challenges and decision points
- Multiple perspectives to consider
- Discussion prompts for reflection

**2. Current Research & Evidence Base (500 words):**
Use search tools to find 6-10 relevant articles from 2020-2024 on "${moduleName}" and "${concept}". For each source:
- **Citation:** Complete Vancouver-style reference
- **Key Findings:** 2-3 sentences on main findings
- **Practice Implications:** How this applies to Australian healthcare

**3. Professional Development Pathway (300 words):**
- Next steps for skill development
- Advanced learning opportunities
- Professional networks and resources
- Continuing education pathways

Return ONLY the final, complete content for both resources, formatted with clear Markdown headings.`;
}

function buildAbsorbLmsPrompt_(moduleName, slideSpecs, downloadableResources) {
  return brandHeader_() + `Create a comprehensive text document optimized for Absorb LMS upload. This will be parsed into individual slides and must maintain educational flow and engagement.

**Module Name:** ${moduleName}

**Source - Slide Specifications:**
---
${slideSpecs}
---

**Integration Requirements:**
1. Convert slide structure into flowing narrative content
2. Maintain clear section breaks for LMS parsing
3. Include interactive elements and engagement prompts
4. Add navigation cues and progress indicators
5. Ensure accessibility compliance
6. Use engaging, conversational tone for online learning

**Enhanced Features to Include:**
- **Interactive Elements:** Questions, reflection prompts, practical exercises
- **Multimedia Cues:** [IMAGE], [VIDEO], [AUDIO] placeholders where appropriate
- **Assessment Integration:** Knowledge check opportunities
- **Resource Links:** Connection points to downloadable materials
- **Progress Tracking:** Clear milestones and completion indicators

**Output Format:**
Use clear Markdown formatting with:
- # for main section headers (will become slide titles)
- ## for subsections
- **Bold** for key terms and concepts
- *Italics* for emphasis and instructions
- > Blockquotes for important callouts
- Numbered lists for step-by-step processes
- Bullet lists for key points

**Engagement Standards:**
- Include "Think About This" reflection boxes
- Add "Try This" practical application prompts  
- Insert "Key Takeaway" summary points
- Use Australian healthcare examples throughout
- Maintain professional but conversational tone

Return ONLY the complete, LMS-ready content with all enhancements integrated.`;
}

function buildSpeakerNotesPrompt(slideContent, moduleName, concept) {
  return brandHeader_() + `Generate a sophisticated, executive-level voiceover script for this presentation slide. The script must be suitable for a 75-90 second professional audio recording.

**Slide Content:**
---
${slideContent}
---

**REQUIREMENTS:**
1. **Executive Authority:** Speak as a senior healthcare leader sharing insights with peers
2. **Natural Flow:** Conversational yet authoritative, avoiding academic jargon
3. **Australian Context:** Reference local healthcare frameworks and challenges naturally
4. **Practical Focus:** Connect concepts to real-world applications and outcomes
5. **Engagement:** Use rhetorical questions and relatable examples
6. **Professional Wisdom:** Demonstrate deep understanding without citing specific sources

**TONE GUIDELINES:**
- Address audience as experienced professionals
- Use "we" language to build connection
- Reference "established practices" rather than specific citations
- Include brief, relevant examples from practice
- Connect to broader healthcare challenges and opportunities

**AVOID:**
- Meta-commentary ("Here's what we'll cover")
- Instructional language ("You should", "Make sure")
- Academic citation format
- Generic transitions ("Moving on", "Next")

**TIMING:** Aim for 180-220 words at natural speaking pace (75-90 seconds).

Return ONLY the polished voiceover script - no stage directions, formatting, or explanatory text.`;
}

function buildImagePrompt(slideContent, moduleName, concept) {
  const slideTitle = slideContent.split('\n')[0].replace(/^#+\s*/, '');
  
  return brandHeader_() + `Create a detailed, single-sentence image generation prompt for a presentation slide.

**Context:**
- Course: ${concept}
- Module: ${moduleName} 
- Slide: ${slideTitle}

**Content Summary:** ${slideContent.slice(0, 300)}...

**Requirements:**
- Professional Australian healthcare setting
- Diverse, inclusive representation
- Modern, clean visual style
- No text overlay or embedded words
- Culturally appropriate and safe
- High contrast for accessibility

**Visual Elements to Consider:**
- Healthcare professionals in consultation
- Modern clinical/office environment
- Professional interactions and teamwork
- Technology integration where relevant
- Supportive, learning-focused atmosphere

Return ONLY a single, detailed sentence describing the image to be generated.`;
}

function buildAlternateSlideContentPrompt(fullSlideContent, moduleName) {
  const slideTitle = fullSlideContent.split('\n')[0].replace(/^#+\s*/, '');
  
  return brandHeader_() + `Transform this slide content from bullet points into an executive-level narrative paragraph suitable for senior healthcare professionals.

**Module:** ${moduleName}
**Original Slide Content:**
---
${fullSlideContent}
---

**TRANSFORMATION REQUIREMENTS:**
1. **NO MARKDOWN:** No formatting characters like '#' or '**'
2. **Title First:** Begin with the slide title exactly as shown, nothing else on line 1
3. **Executive Narrative:** Convert bullet points into sophisticated, flowing prose
4. **Professional Tone:** Write for peer-to-peer communication at senior level
5. **Practical Focus:** Emphasize application and strategic thinking
6. **Concise Excellence:** Maximum 60-80 words of substantive content

**OUTPUT FORMAT:**
Line 1: [Exact slide title]
Line 2: [Empty line]
Line 3+: [Single sophisticated paragraph combining all bullet points into flowing narrative]

**Example Style:**
Clinical Assessment Frameworks
Clinical assessment in Australian healthcare requires integrated approaches that balance evidence-based standards with individualized patient care. Effective frameworks incorporate systematic observation, documentation protocols, and collaborative decision-making processes. Contemporary practice emphasizes cultural safety, shared decision-making, and continuous quality improvement to ensure optimal patient outcomes while supporting clinician professional development and organizational learning objectives.

Return ONLY the formatted content as specified.`;
}

// ---- Specialized Content Generation Functions ----
function generateAdvancedSlideContent_(slideSpecs, moduleName, concept, targetAudience = 'Clinical') {
  const slides = parseSlideSpecs(slideSpecs);
  const enhancedSlides = [];
  
  for (let i = 0; i < slides.length; i++) {
    const slide = slides[i];
    const prompt = brandHeader_() + `Create sophisticated slide content for senior healthcare professionals.

**Context:** Module "${moduleName}" in "${concept}" course for ${targetAudience} audience
**Slide ${i + 1}:** ${slide.title}
**Original Concepts:** ${slide.body.join('; ')}

**Create executive-level content that:**
- Transforms concepts into strategic insights
- Uses authoritative yet accessible language  
- References Australian healthcare context naturally
- Includes practical applications and implications
- Demonstrates professional wisdom and experience
- Avoids academic citations - speak from authority

**Format:** Title + 2-3 cohesive paragraphs (60-80 words total)
**Tone:** Senior colleague sharing insights with peers

Return only the enhanced slide content.`;

    try {
      const enhanced = au(callGeminiWithRetry(prompt, 1200, 3, 0.6));
      enhancedSlides.push(enhanced);
      
      // Rate limiting
      if (i < slides.length - 1) {
        Utilities.sleep(7000);
      }
    } catch (error) {
      console.error(`Error enhancing slide ${i + 1}:`, error.message);
      // Fallback to original format
      enhancedSlides.push(`${slide.title}\n\n${slide.body.join('. ')}`);
    }
  }
  
  return enhancedSlides;
}

function generateContextualImagePrompts_(slideContent, concept, moduleName) {
  const prompts = [];
  const slides = Array.isArray(slideContent) ? slideContent : [slideContent];
  
  slides.forEach((slide, index) => {
    const lines = String(slide).split('\n').filter(line => line.trim());
    const title = lines[0] || `Slide ${index + 1}`;
    
    let contextualPrompt = '';
    const content = slide.toLowerCase();
    
    // Context-specific image generation
    if (content.includes('assessment') || content.includes('evaluation')) {
      contextualPrompt = `Healthcare professional conducting clinical assessment in modern Australian medical facility - ${title}, diverse healthcare team, professional documentation, contemporary evaluation tools, supportive learning environment`;
    } else if (content.includes('communication') || content.includes('feedback')) {
      contextualPrompt = `Healthcare professionals engaged in mentoring conversation in Australian medical practice - ${title}, supervisor and learner interaction, supportive professional development, clinical supervision setting`;
    } else if (content.includes('cultural') || content.includes('diversity')) {
      contextualPrompt = `Diverse healthcare team collaboration in Australian clinical setting - ${title}, multicultural professionals, culturally safe practices, inclusive healthcare delivery`;
    } else if (content.includes('technology') || content.includes('digital')) {
      contextualPrompt = `Modern healthcare technology integration in Australian clinical practice - ${title}, digital health tools, professional training, contemporary medical equipment`;
    } else if (content.includes('leadership') || content.includes('management')) {
      contextualPrompt = `Healthcare leadership meeting in professional Australian medical setting - ${title}, senior clinicians, strategic discussion, executive healthcare environment`;
    } else {
      contextualPrompt = `Professional healthcare education scene in contemporary Australian medical setting - ${title}, clinical learning environment, diverse healthcare professionals, modern educational context`;
    }
    
    prompts.push({
      slideNumber: index + 1,
      title: title,
      prompt: contextualPrompt + ', photo-realistic professional photography style'
    });
  });
  
  return prompts;
}

// ---- Batch Processing Functions ----
function batchGenerateModuleContent_(moduleData, batchSize = 3) {
  const results = [];
  const totalModules = moduleData.length;
  
  for (let i = 0; i < totalModules; i += batchSize) {
    const batch = moduleData.slice(i, i + batchSize);
    const batchResults = [];
    
    trackProgress('Batch Content Generation', i, totalModules, `Processing batch ${Math.floor(i/batchSize) + 1}...`);
    
    batch.forEach((module, index) => {
      try {
        const result = {
          moduleName: module.name,
          description: generateModuleDescription_(module.name, module.concept),
          keyPoints: generateKeyPoints_(module.description, module.name),
          slideSpecs: generateSlideSpecs_(module.description, module.keyPoints, module.name),
          assessments: generateAssessments_(module.name, module.description),
          scenarios: generateScenarios_(module.name, module.description)
        };
        batchResults.push(result);
        
        // Inter-module delay within batch
        if (index < batch.length - 1) {
          Utilities.sleep(3000);
        }
      } catch (error) {
        console.error(`Error processing module ${module.name}:`, error.message);
        batchResults.push({ moduleName: module.name, error: error.message });
      }
    });
    
    results.push(...batchResults);
    
    // Inter-batch delay
    if (i + batchSize < totalModules) {
      Utilities.sleep(10000); // 10 second delay between batches
    }
  }
  
  return results;
}

// ---- Quality Assurance Functions ----
function validatePromptQuality_(prompt, expectedLength = 100) {
  const issues = [];
  
  if (!prompt || typeof prompt !== 'string') {
    issues.push('Prompt is not a valid string');
  } else {
    if (prompt.length < expectedLength) {
      issues.push(`Prompt too short (${prompt.length} chars, expected ${expectedLength}+)`);
    }
    
    if (!prompt.includes('Australian')) {
      issues.push('Missing Australian healthcare context');
    }
    
    if (!prompt.includes(CFG.BRAND_HEADER.slice(0, 20))) {
      issues.push('Missing brand header');
    }
    
    // Check for placeholder text
    const placeholders = ['[INSERT]', '[TODO]', '[PLACEHOLDER]'];
    placeholders.forEach(placeholder => {
      if (prompt.includes(placeholder)) {
        issues.push(`Contains placeholder: ${placeholder}`);
      }
    });
  }
  
  return {
    isValid: issues.length === 0,
    issues: issues
  };
}

function optimizePromptForModel_(prompt, modelType = 'gemini', maxLength = 8000) {
  let optimized = String(prompt || '').trim();
  
  // Model-specific optimizations
  switch (modelType.toLowerCase()) {
    case 'gemini':
      // Gemini prefers clear structure and specific instructions
      if (optimized.length > maxLength) {
        // Truncate while preserving structure
        const sections = optimized.split('\n\n');
        let truncated = sections[0]; // Keep header
        
        for (let i = 1; i < sections.length; i++) {
          if (truncated.length + sections[i].length < maxLength - 100) {
            truncated += '\n\n' + sections[i];
          } else {
            break;
          }
        }
        optimized = truncated + '\n\n[Content truncated for optimal processing]';
      }
      break;
      
    default:
      if (optimized.length > maxLength) {
        optimized = optimized.slice(0, maxLength - 50) + '...[truncated]';
      }
  }
  
  return optimized;
}

// ---- Export for Testing ----
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    callGeminiWithRetry,
    buildCourseRecommendationPrompt_,
    buildModuleDescriptionPrompt,
    generateAdvancedSlideContent_,
    validatePromptQuality_
  };
}

// ==== C) Menu & UI ====

// ---- Menu initialisation ----
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('Concept-to-Course')
      .addItem('#1 Setup & Add First Course', 'setupMappingTab')
      .addItem('#2 Generate Course Recommendation', 'generateCourseRecommendation')
      .addItem('#3 Create Content Tabs & Subfolders', 'createCourseContentTabs')
      .addSeparator()
      .addItem('#4 Generate Full Suite of Resources', 'generateFullSuiteOfResources')
      .addItem('#5 Generate LMS Upload Doc', 'generateAbsorbLmsFile')
      .addSeparator()
      .addSubMenu(ui.createMenu('SLIDES & AUDIO')
          .addItem('#6 Generate Slides for Module', 'generateSlidesForSelectedModule')
          .addItem('#7 Set Voiceover Artist', 'setTtsVoice_')
          .addItem('#8 Generate All Audio for Module', 'generateAllAudioForModule'))
      .addSeparator()
      .addSubMenu(ui.createMenu('DATA & ARCHIVAL')
          .addItem('#9 Clean Module Audio Files', 'cleanModuleAudioFiles')
          .addItem('#10 Archive Course Project', 'archiveCourse'))
      .addToUi();
}

function addMenu_(menu, label, fnName) {
  try {
    if (typeof this[fnName] === 'function') menu.addItem(label, fnName);
  } catch(_) { /* skip if missing */ }
}

// ==== D) Utilities & Mapping ====

/**
 * Extract module names from an AI recommendation doc/string.
 * Looks for a "RECOMMENDED MODULES" block and normalises bullets.
 */
function extractModuleNames_(text){
  const src = String(text || '');

  // 1) Isolate the "RECOMMENDED MODULES" block up to next section heading
  const blockMatch = src.match(/RECOMMENDED MODULES\s*:?\s*([\s\S]+?)(?:\n[A-Z ]{4,}\s*:|^\s*(?:ASSESSMENTS?|REFERENCES?|SOURCES|ADDITIONAL RECOMMENDED SOURCES)\b|$)/im);
  const block = blockMatch ? blockMatch[1] : src;

  // 2) Split lines, remove markdown noise, keep non-empty
  const lines = block
    .replace(/\r/g,'')
    .split('\n')
    .map(l => l.replace(/\*\*/g,'').trim())
    .filter(Boolean);

  const names = [];
  const seen = new Set();

  function pushName(raw){
    if (!raw) return;
    let name = String(raw).trim();

    // remove leading bullets & ordering
    name = name.replace(/^\s*(?:[-*•]|\d+[.)])\s*/,'');
    // strip trailing punctuation
    name = name.replace(/[.:;,-\s]+$/,'').trim();
    // drop bracketed metadata
    name = name.replace(/\s*\([^)]*\)\s*$/,'').trim();

    // prune common prefixes if the AI returns “Module:” etc.
    name = name.replace(/^module\s*[:\-]\s*/i,'').trim();

    if (name && !seen.has(name.toLowerCase())){
      seen.add(name.toLowerCase());
      names.push(name);
    }
  }

  lines.forEach(ln => {
    // split composite bullets like "1) Title — subtitle"
    const parts = ln.split(/—|–|:|•|\|/).filter(Boolean);
    pushName(parts[0] || ln);
  });

  // heuristic safeguard: return unique, 2–100 chars
  return names.filter(s => s.length >= 2 && s.length <= 100);
}

/**
 * Take a recommendation doc (Google Doc URL or raw text), extract module names,
 * and write into Mapping sheet module column.
 */
function refreshModulesFromRecommendation(){
  const ss = SpreadsheetApp.getActive();
  const map = ss.getSheetByName('Mapping');
  if (!map) throw new Error('Mapping sheet not found.');

  const recUrl = String(map.getRange('N2').getValue() || '').trim(); // Recommendation Doc URL (example placement)
  const moduleCol = 5; // Column E (example) – adjust to your layout

  let text = '';
  if (recUrl){
    const id = extractIdFromUrl_(recUrl);
    if (!id) throw new Error('Invalid recommendation Doc URL.');
    text = DocumentApp.openById(id).getBody().getText() || '';
  } else {
    text = String(map.getRange('N3').getValue() || ''); // optional raw paste
  }

  const modules = extractModuleNames_(text);
  if (!modules.length){
    SpreadsheetApp.getUi().alert('No modules detected in the recommendation content.');
    return;
  }

  // clear existing module list (E3:E)
  const last = map.getLastRow();
  if (last >= 3){
    map.getRange(3, moduleCol, last-2, 1).clearContent();
  }

  map.getRange(3, moduleCol, modules.length, 1).setValues(modules.map(m => [m]));
  SpreadsheetApp.getUi().alert(`Inserted ${modules.length} modules into Mapping.`);
}

/**
 * Create an "Approved Course" tab and seed headings for downstream use.
 */
function createApprovedCourseTab(){
  const ss = SpreadsheetApp.getActive();
  let sh = ss.getSheetByName('Approved Course');
  if (!sh){
    sh = ss.insertSheet('Approved Course');
  } else {
    sh.clear();
  }
  sh.getRange(1,1,1,6).setValues([[
    'Module #','Module Name','Learning Objectives','Key Concepts','Assessment Items','Notes'
  ]]);
}

/**
 * Setup Mapping sheet with required fields and gentle defaults.
 * (Non-destructive for existing content; ensures headings are present.)
 */
function setupMappingTab(){
  const ss = SpreadsheetApp.getActive();
  let sh = ss.getSheetByName('Mapping');
  if (!sh){ sh = ss.insertSheet('Mapping'); }

  const headers = [
    'Course Concept',        // A
    'Course Drive Folder',   // B (Folder URL)
    'Slides Template',       // C (Slides template URL)
    'Active Module',         // D
    'Modules',               // E+
    // ... your existing columns beyond E remain intact
  ];

  // Write headers into row1 where empty; don’t overwrite existing labels.
  const existing = sh.getRange(1,1,1,headers.length).getValues()[0];
  const out = existing.slice();
  headers.forEach((h,i)=>{ if (!String(existing[i]||'').trim()) out[i]=h; });
  sh.getRange(1,1,1,headers.length).setValues([out]);

  // Leave data alone; simply ensure the tab exists and is minimally labelled.
}

/**
 * Wrapper to gather all sources for the active Mapping row via collectAllSourceMaterials_.
 * Returns only the combined text (status logs any warnings).
 */
function readSourceMaterials_(){
  const sh = SpreadsheetApp.getActive().getSheetByName('Mapping');
  if (!sh) throw new Error('Mapping sheet not found.');
  const row = sh.getActiveRange().getRow();
  const pack = collectAllSourceMaterials_(row); // B[row] + B[row+1..] + inline URLs (no T ingestion)

  if (pack.errors && pack.errors.length){
    const status = ensureStatusSheet_();
    status.appendRow([new Date(), 'readSourceMaterials_', 'warn', pack.errors.join(' | ')]);
  }
  return String(pack.text || '');
}

/**
 * (Robust) Ensure a TTS sheet exists for a module and return it.
 */
function ensureTTSSheet(concept, moduleName){
  const ss = SpreadsheetApp.getActive();
  const safeName = `TTS-${(String(moduleName||'').slice(0,32) || 'Module').replace(/[^\w -]/g,'_')}`;
  let sh = ss.getSheetByName(safeName);
  if (!sh){
    sh = ss.insertSheet(safeName);
    sh.getRange(1,1,1,10).setValues([[
      'Module','Slide #','Script','Image Prompt','Alt Text','Voice',
      'Backup Image Prompt','Audio File Id','Audio URL','Notes'
    ]]);
  }
  return sh;
}

/**
 * Given slide specs text, parse, enrich, and seed a TTS sheet.
 * Uses parseSlideSpecs_ (Section F) and generateImagePrompt (Section F).
 */
function seedTTSFromSpecs(concept, moduleName, slideSpecsText){
  const slides = parseSlideSpecs_(slideSpecsText);
  const tts = ensureTTSSheet(concept, moduleName);
  const rows = [];

  for (let i = 0; i < slides.length; i++){
    const slide = slides[i];
    try {
      // Build a concise, narrative script and an image prompt
      const content = populateAlternateSlideContent(slide, concept, moduleName);
      const imagePrompt = generateImagePromptForSlide(slide, concept, moduleName);
      rows.push([moduleName, i+1, content, imagePrompt, '', '', '', '', '', '']);
    } catch(e){
      // Fallback to a simple bullet-massage if enrichment fails
      const fallbackContent = `${slide.title}\n\n${(slide.body || []).map(b => b.replace(/^\s*[-*•]\s*/, '').trim()).join('. ')}`;
      const fallbackImagePrompt = generateImagePrompt(fallbackContent, concept, moduleName);
      rows.push([moduleName, i+1, fallbackContent, fallbackImagePrompt, '', '', '', '', '', '']);
    }
  }

  if (rows.length){
    const start = tts.getLastRow()+1;
    tts.getRange(start,1,rows.length,10).setValues(rows);
  }

  trackProgress('Seed TTS from Specs', rows.length, rows.length, `Created TTS rows for "${moduleName}"`);
}

/** Extract URLs from text for optional augmentation */
function extractUrls_(text){
  const re = /\bhttps?:\/\/[^\s)<>"']+/gi;
  const out = [];
  let m;
  while ((m = re.exec(String(text||''))) !== null){
    out.push(m[0]);
  }
  return Array.from(new Set(out));
}

/** Light HTML→text normaliser for fetched web pages */
function htmlToText_(html){
  return String(html||'')
    .replace(/<\s*script[^>]*>[\s\S]*?<\s*\/\s*script>/gi, ' ')
    .replace(/<\s*style[^>]*>[\s\S]*?<\s*\/\s*style>/gi, ' ')
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n\n')
    .replace(/<[^>]+>/g, ' ')
    .replace(/\n{3,}/g, '\n\n')
    .replace(/[ \t]{2,}/g, ' ')
    .trim();
}

/** Fetch a single URL body with mild guardrails (type/size/timeouts) */
function fetchUrlText_(url){
  try{
    const resp = UrlFetchApp.fetch(url, {
      method: 'get',
      followRedirects: true,
      muteHttpExceptions: true,
      validateHttpsCertificates: true,
      contentType: 'text/plain',
      timeout: 20000
    });
    const code = resp.getResponseCode();
    if (code < 200 || code >= 300) return { text:'', error:`HTTP ${code} for ${url}` };
    const ctype = String(resp.getHeaders()['Content-Type'] || '').toLowerCase();
    if (!/(text|html|json|xml)/.test(ctype)) return { text:'', error:`Skipped non-text content: ${ctype} ${url}` };
    const body = resp.getContentText() || '';
    const text = /html/.test(ctype) ? htmlToText_(body) : body;
    return { text, error:'' };
  }catch(e){
    return { text:'', error:`Fetch error for ${url}: ${e.message}` };
  }
}

/** Fetch a bundle of URLs and concatenate text (limited) */
function fetchUrlsBundle_(urls, limit=10){
  const use = Array.from(new Set(urls||[])).slice(0, limit);
  const parts = [];
  const errors = [];
  use.forEach(u=>{
    const r = fetchUrlText_(u);
    if (r.text) parts.push(`\n\n=== SOURCE: ${u} ===\n${r.text}`);
    if (r.error) errors.push(r.error);
  });
  return { text: parts.join('\n'), errors };
}

/**
 * Collect source materials for a course.
 * Modes:
 *  - Legacy: if arg is a Drive Folder, read it recursively (old behavior).
 *  - Preferred: if arg is missing or a row number, read Mapping:
 *      • B[row] primary + B[row+1..until next non-empty A] additional
 *      • DOES NOT ingest from T[row] (T is for filing/archival only)
 *  - In both modes: crawl inline URLs found in the aggregated text (guarded).
 * Returns: { text, errors, sources }
 */
function collectAllSourceMaterials_(arg){
  // ----- Legacy folder mode -----
  if (arg && typeof arg.getFiles === 'function') {
    const { text, errors } = readFromFolder_(arg);
    const urls = extractUrls_(text || '');
    const uniq = Array.from(new Set(urls)).slice(0, (typeof URL_CRAWL_LIMIT !== 'undefined' ? URL_CRAWL_LIMIT : 12));
    let appended = '', appendedLen = 0, crawlErr = [];
    uniq.forEach(u => {
      const r = fetchUrlText_(u);
      const t = (typeof r === 'string') ? r : (r && r.text) || '';
      if (t) {
        const chunk = `\n\n===== SOURCE: ${u} (Inline URL) =====\n${t}`;
        const cap = (typeof URL_MAX_APPEND_CHARS !== 'undefined' ? URL_MAX_APPEND_CHARS : 20000);
        if (appendedLen + chunk.length <= cap) { appended += chunk; appendedLen += chunk.length; }
      }
      if (r && r.error) crawlErr.push(r.error);
    });
    return { text: (text || '') + appended, errors: [].concat(errors || [], crawlErr), sources: [] };
  }

  // ----- Mapping B-block mode -----
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName('Mapping');
  if (!sh) throw new Error('Mapping sheet not found.');

  const row = (typeof arg === 'number' && arg >= 2) ? arg : sh.getActiveRange().getRow();
  if (row < 2) throw new Error('Select a course row (row ≥ 2).');

  const concept = String(sh.getRange(row, 1).getValue() || '').trim();
  if (!concept) throw new Error('Course Concept (Column A) is empty on the selected row.');

  // find end of this course block (next non-empty A)
  const lastRow = sh.getLastRow();
  let end = lastRow + 1;
  for (let r = row + 1; r <= lastRow; r++){
    if (String(sh.getRange(r, 1).getValue() || '').trim()) { end = r; break; }
  }

  const errors = [];
  const parts = [];
  /** @type {{type:'web'|'gdoc'|'gfolder'|'pdf'|'text', title?:string, url?:string, id?:string}[]} */
  const sources = [];

  function push(label, t){
    if (t && String(t).trim()) parts.push(`\n\n===== SOURCE: ${label} =====\n${String(t).trim()}`);
  }

  function readDriveFileText_(id){
    try{
      const f   = DriveApp.getFileById(id);
      const nm  = f.getName();
      const mime= String(f.getMimeType()||'').toLowerCase();
      if (mime.includes('document')){
        sources.push({type:'gdoc', title:nm, id, url:`https://docs.google.com/document/d/${id}/edit`});
        return DocumentApp.openById(id).getBody().getText() || '';
      }
      if (mime.includes('pdf')){
        sources.push({type:'pdf', title:nm, id, url:`https://drive.google.com/file/d/${id}/view`});
        try{
          const parentId = f.getParents().hasNext() ? f.getParents().next().getId() : null;
          const conv = Drive.Files.insert({title:'_ingest_'+nm, mimeType:'application/pdf', parents: parentId ? [{id: parentId}] : []}, f.getBlob(), {convert:true});
          return DocumentApp.openById(conv.id).getBody().getText() || '';
        } catch(e){
          try { return f.getBlob().getDataAsString(); } catch(_) { errors.push(`${nm}: PDF conversion unavailable`); return ''; }
        }
      }
      // generic text-ish
      try { return f.getBlob().getDataAsString(); } catch(e){ errors.push(`${nm}: ${e.message}`); return ''; }
    }catch(e){
      errors.push(`Drive read failed (${id}): ${e.message}`); return '';
    }
  }

  function processOne_(label, val){
    const s = String(val||'').trim();
    if (!s) return;

    const folderMatch = s.match(/\/folders\/([A-Za-z0-9_-]{10,})/);
    if (folderMatch){
      try{
        const folder = DriveApp.getFolderById(folderMatch[1]);
        sources.push({type:'gfolder', title: folder.getName(), id: folderMatch[1], url: s});
        const r = readFromFolder_(folder);
        push(`${label} (Drive Folder)`, r.text);
        if (r.errors && r.errors.length) errors.push.apply(errors, r.errors);
      }catch(e){ errors.push(`Folder read failed (${s}): ${e.message}`); }
      return;
    }

    const id = extractIdFromUrl_(s);
    if (id){ push(`${label} (Drive File)`, readDriveFileText_(id)); return; }

    if (/^https?:\/\//i.test(s)){
      const r = fetchUrlText_(s);
      const t = (typeof r === 'string') ? r : (r && r.text) || '';
      push(`${label} (Web)`, t);
      sources.push({type:'web', title: s, url: s});
      if (r && r.error) errors.push(r.error);
      return;
    }

    push(`${label} (Text)`, s);
    sources.push({type:'text', title: label});
  }

  // B[row] + B[row+1..end-1]
  const primary = sh.getRange(row,2).getValue();
  if (primary) processOne_(`B${row}`, primary);
  if (end > row + 1){
    const more = sh.getRange(row+1,2, (end-row-1), 1).getValues();
    more.forEach((a,i)=>{ const v=a[0]; if (String(v||'').trim()) processOne_(`B${row+1+i}`, v); });
  }
  // DO NOT ingest from T[row].

  // inline URLs
  let combined = parts.join('\n');
  const urls = extractUrls_(combined || '');
  const uniq = Array.from(new Set(urls)).slice(0, (typeof URL_CRAWL_LIMIT !== 'undefined' ? URL_CRAWL_LIMIT : 12));
  let appended = '', appendedLen = 0, crawlErr = [];
  uniq.forEach(u => {
    const r = fetchUrlText_(u);
    const t = (typeof r === 'string') ? r : (r && r.text) || '';
    if (t){
      const chunk = `\n\n===== SOURCE: ${u} (Inline URL) =====\n${t}`;
      const cap = (typeof URL_MAX_APPEND_CHARS !== 'undefined' ? URL_MAX_APPEND_CHARS : 20000);
      if (appendedLen + chunk.length <= cap) { appended += chunk; appendedLen += chunk.length; }
    }
    if (r && r.error) crawlErr.push(r.error);
    sources.push({type:'web', title:u, url:u});
  });

  return { text: combined + appended, errors: crawlErr, sources };
}

/**
 * Recursive folder reader. Tries to extract textual content from:
 * - Google Docs (open & read body)
 * - PDFs (convert to Doc if Advanced Drive is enabled; fallback to blob as text)
 * - Other text-like blobs via getDataAsString()
 */
function readFromFolder_(folder){
  let content = '';
  const errors = [];

  // files in the current folder
  const files = folder.getFiles();
  while (files.hasNext()){
    const f = files.next();
    const name = f.getName();
    try {
      const mime = String(f.getMimeType() || '').toLowerCase();
      if (mime.indexOf('document') >= 0){
        const t = DocumentApp.openById(f.getId()).getBody().getText() || '';
        content += `\n\n--- ${name} ---\n${t}\n`;
      } else if (mime.indexOf('pdf') >= 0){
        try {
          // Advanced Drive API conversion (needs enabling)
          const converted = Drive.Files.insert(
            {title:'_ingest_'+name, mimeType:'application/pdf', parents:[{id: folder.getId()}]},
            f.getBlob(), {convert:true}
          );
          const t = DocumentApp.openById(converted.id).getBody().getText() || '';
          content += `\n\n--- ${name} (PDF→Doc) ---\n${t}\n`;
        } catch(e){
          // fallback: attempt raw text
          try { content += `\n\n--- ${name} (raw) ---\n` + f.getBlob().getDataAsString() + '\n'; }
          catch(_) { errors.push(`${name}: PDF conversion not available`); }
        }
      } else {
        // try blob text for txt/rtf/markdown/etc
        try { content += `\n\n--- ${name} ---\n` + f.getBlob().getDataAsString() + '\n'; }
        catch(e){ errors.push(`${name}: ${e.message}`); }
      }
    } catch(e){
      errors.push(`${name}: ${e.message}`);
    }
  }

  // recurse into sub-folders
  const subs = folder.getFolders();
  while (subs.hasNext()){
    const sub = subs.next();
    const r = readFromFolder_(sub);
    content += r.text;
    if (r.errors && r.errors.length) errors.push(...r.errors);
  }

  return { text: content, errors };
}

/** Drive/Slides URL → id extractor (generic 25+ char id) */
function extractIdFromUrl_(u){
  if (!u) return '';
  const m = String(u).match(/[-\w]{25,}/);
  return m ? m[0] : '';
}
function presIdFromUrl(u){ return extractIdFromUrl_(u); }

/** Compatibility aliases if used elsewhere */
function readAllFilesRecursive(folder){ return readFromFolder_(folder); }

/** Return last used resource row in Mapping for a given column set */
function getLastUsedResourceRow(sh){
  const last = sh.getLastRow();
  for (let r = last; r >= 3; r--){
    const v = String(sh.getRange(r,2).getValue() || '').trim(); // col B default
    if (v) return r;
  }
  return 2;
}

/** Convenience to fetch concept/module context from Mapping */
function getActiveModuleInfo_(){
  const ss = SpreadsheetApp.getActive();
  const map = ss.getSheetByName('Mapping');
  if (!map) throw new Error('Mapping sheet not found.');
  const concept = String(map.getRange('A2').getValue() || '').trim();
  const moduleName = String(map.getRange('D2').getValue() || '').trim();
  if (!concept) throw new Error('Provide Course Concept in Mapping!A2.');
  if (!moduleName) throw new Error('Provide Active Module in Mapping!D2.');
  return { concept, moduleName };
}

/** Idempotent folder getter/creator within a parent folder */
function getOrCreateFolder_(parentFolder, name){
  const it = parentFolder.getFoldersByName(name);
  if (it.hasNext()) return it.next();
  return parentFolder.createFolder(name);
}

/** Create/get subfolder for a module under a course root */
function getModuleSubfolder_(courseFolder, moduleName){
  const safe = (String(moduleName||'').replace(/[^\w -]/g,'_') || 'Module');
  return getOrCreateFolder_(courseFolder, safe);
}

/** Basic validation of Mapping inputs before running generators */
function validateRequiredInputs(){
  const ss = SpreadsheetApp.getActive();
  const map = ss.getSheetByName('Mapping');
  if (!map) throw new Error('Mapping sheet not found.');

  const concept = String(map.getRange('A2').getValue() || '').trim();
  const folderUrl = String(map.getRange('B2').getValue() || map.getRange('T2').getValue() || '').trim();
  const templateUrl = String(map.getRange('C2').getValue() || '').trim();

  const errors = [];
  if (!concept) errors.push('Course Concept (A2)');
  if (!folderUrl) errors.push('Course Drive Folder URL (B2 or T2)');
  if (!templateUrl) errors.push('Slides Template URL (C2)');

  if (errors.length) throw new Error('Missing required: ' + errors.join(', '));
  return {
    concept,
    courseFolder: DriveApp.getFolderById(extractIdFromUrl_(folderUrl)),
    templateId: extractIdFromUrl_(templateUrl)
  };
}

/** Lightweight UI + logging progress tracker */
function trackProgress(title, current, total, message){
  try {
    SpreadsheetApp.getActive().toast(`${title}: ${current}/${total} — ${message}`);
    const sh = ensureStatusSheet_();
    sh.appendRow([new Date(), title, `${current}/${total}`, message]);
  } catch(_) {}
}

/** Ensure Status sheet exists */
function ensureStatusSheet_(){
  const ss = SpreadsheetApp.getActive();
  const name = 'Status';
  let sh = ss.getSheetByName(name);
  if (!sh){
    sh = ss.insertSheet(name);
    sh.getRange(1,1,1,4).setValues([['Timestamp','Action','Progress','Details']]);
  }
  return sh;
}

// ==== E) Core Workflow Functions ====

// --- Your exact TTS constants ---
const VOICE_NAME = 'Schedar';
const SPEECH_TEMPERATURE = 0.5;
const AUSTRALIAN_PROMPT = `You are a highly educated Australian with a warm, personable delivery. Speak with the refined Australian accent of educated professionals - a subtle blend of American, western European and British influences with softer jaw movement than American English, but more open than formal British. Maintain professional warmth without any exaggerated regional characteristics. This is healthcare professional development content - absolutely NO colloquialisms, slang, or casual Australian expressions (no 'G'day', 'mate', 'fair dinkum', etc.). Use sophisticated, professional language appropriate for medical professionals and senior administrators. This is an educational offering for adult learners who are themselves educators, so infuse your tone with authority and sincerity, minimising chirpiness. Read this with confident executive presence as if the listener is a peer not a subordinate:`;

// ---- Course recommendation & mapping ----
function generateCourseRecommendation(){
  const sh = SpreadsheetApp.getActiveSheet();
  if (sh.getName() !== 'Mapping') return SpreadsheetApp.getUi().alert('Run on the Mapping tab.');
  const r = sh.getActiveRange().getRow();
  if (r === 1) return SpreadsheetApp.getUi().alert('Select a data row.');

  const concept = sh.getRange(r,1).getValue();
  const audience = sh.getRange(r,3).getValue() || 'Clinical';
  const courseFolderUrl = sh.getRange(r,20).getValue();
  if (!concept) return SpreadsheetApp.getUi().alert('Fill Concept (A).');
  if (!courseFolderUrl) return SpreadsheetApp.getUi().alert('Missing Course Project Folder (Column T).');

  // Multi-source pack (B2 + B3:B + T + inline URLs)
  const srcPack = collectAllSourceMaterials_(r);
  if (srcPack.errors.length) SpreadsheetApp.getUi().alert('Some resources could not be fetched:\n' + srcPack.errors.join('\n'));
  if (!srcPack.text.trim()) return SpreadsheetApp.getUi().alert('No source materials were retrieved.');

  // Build the prompt: your brand header + course mapping prompt + Vancouver requirement
  const mappingPrompt = brandHeader_() + '\n' + COURSE_MAPPING_PROMPT +
    `\n\nCONCEPT: ${concept}\nSELECTED TARGET AUDIENCE: ${audience}\n` +
    VANCOUVER_CITATION_INSTRUCTIONS +
    `\n\nSOURCE MATERIALS PROVIDED:\n${String(srcPack.text).slice(0,12000)}`;

  const rec = callGemini(mappingPrompt, 7000); // your existing helper

  // Create/attach doc
  const doc = DocumentApp.create(`${concept}_Recommendations_${new Date().toISOString().slice(0,16).replace('T','_')}`);
  let file = DriveApp.getFileById(doc.getId());
  DriveApp.getFolderById(courseFolderUrl.split('/folders/')[1]).addFile(file);
  DriveApp.getRootFolder().removeFile(file);

  // Append recommendation
  const body = doc.getBody();
  body.appendParagraph(rec);

  // Deterministic Vancouver appendix (from the exact sources we ingested)
  const refs = formatVancouverReferences_(srcPack.sources);
  if (refs){
    body.appendParagraph('\n\nReferences').setHeading(DocumentApp.ParagraphHeading.HEADING2);
    body.appendParagraph(refs);
  }
  doc.saveAndClose();

  // (Continue your existing module-name extraction + writeback)
  const names = extractModuleNames_(rec);
  sh.getRange(r,7).setValue(names.join('\n'));
  for (let i=0;i<12;i++){ sh.getRange(r,8+i).setValue(names[i]||''); }

  SpreadsheetApp.getUi().alert('Course recommendation generated with Vancouver-style citations.');
}

function processModificationRequest(){
  const sh = SpreadsheetApp.getActiveSheet();
  if (sh.getName() !== 'Mapping') return SpreadsheetApp.getUi().alert('Run on the Mapping tab.');
  const r = sh.getActiveRange().getRow();
  const concept = sh.getRange(r,1).getValue();
  const request = sh.getRange(r,6).getValue();
  const docUrl = sh.getRange(r,4).getValue();
  if (!request || !docUrl) return SpreadsheetApp.getUi().alert('Need Modification Request (F) and Recommendations link (D).');

  const docId = presIdFromUrl(docUrl) || extractIdFromUrl_(docUrl);
  let currentText = '';
  try{ currentText = DocumentApp.openById(docId).getBody().getText(); }catch(e){}

  const prompt = brandHeader_() + `
Revise the existing course recommendation for "${concept}" based on this request:

${request}

Current document text:
${currentText}

Return the complete revised recommendation with the same headings and refreshed module list.`;
  const revised = callGemini(prompt, 7000);
  const doc = DocumentApp.openById(docId);
  doc.getBody().clear(); doc.getBody().appendParagraph(revised); doc.saveAndClose();

  const names = extractModuleNames_(revised);
  sh.getRange(r,7).setValue(names.join('\n'));
  for (let i=0;i<12;i++){ sh.getRange(r,8+i).setValue(names[i]||''); }
  sh.getRange(r,6).clearContent();
  SpreadsheetApp.getUi().alert('Recommendation updated and module list refreshed.');
}

function createCourseContentTabs() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const mappingSheet = ss.getSheetByName('Mapping');
  if (!mappingSheet) return ui.alert('Run "#1 Setup" first.');
  
  const row = mappingSheet.getActiveCell().getRow();
  if (row < 2) return ui.alert('Select a row.');

  const courseName = mappingSheet.getRange(row, 1).getValue();
  const courseFolderUrl = mappingSheet.getRange(row, 20).getValue(); // Column T
  if (!courseName || !courseFolderUrl) return ui.alert('Run steps #1 and #2 first.');
  
  const courseFolderId = extractIdFromUrl_(courseFolderUrl);
  const courseFolder   = DriveApp.getFolderById(courseFolderId);
  const moduleNames = mappingSheet.getRange(row, 8, 1, 12).getValues()[0].filter(String);
  
  if (moduleNames.length === 0) return ui.alert('No module names found in columns H-S. Please run step #2 first.');

  SpreadsheetApp.getActiveSpreadsheet().toast('Creating module subfolders...');
  moduleNames.forEach((name, index) => {
    const sanitizedName = name.replace(/[^a-zA-Z0-9\s-]/g, '');
    getOrCreateFolder_(courseFolder, `Module ${index + 1} - ${sanitizedName}`);
  });
  
  const resourcesSheetName = `Module-Resources-${courseName}`;
  if (!ss.getSheetByName(resourcesSheetName)) {
      const template = ss.getSheetByName('Module-Resources-Template');
      const newSheet = template ? template.copyTo(ss) : ss.insertSheet();
      newSheet.setName(resourcesSheetName);
      if(moduleNames.length > 0) {
          const data = moduleNames.map(m => [m, courseName]);
          newSheet.getRange(2, 1, data.length, 2).setValues(data);
      }
  }

  const ttsSheetName = `TTS-${courseName}`;
  if (!ss.getSheetByName(ttsSheetName)) {
      const template = ss.getSheetByName('TTS-{ConceptName}');
      const newSheet = template ? template.copyTo(ss) : ss.insertSheet();
      newSheet.setName(ttsSheetName);
  }
  
  ui.alert('Setup Complete', `Module subfolders have been created in your project folder, and the content tabs are ready.`, ui.ButtonSet.OK);
}

function generateFullSuiteOfResources() {
  const { sheet, row, moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;

  const moduleSubfolder = getModuleSubfolder_(conceptName, moduleName);
  if (!moduleSubfolder) return;

  if (!sheet.getRange(row, 3).getValue()) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Generating Module Description...');
      const descPrompt = buildModuleDescriptionPrompt(moduleName, conceptName);
      sheet.getRange(row, 3).setValue(callGeminiApi_(descPrompt));
  }
  const moduleDescription = sheet.getRange(row, 3).getValue();
  if (!sheet.getRange(row, 4).getValue()) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Generating Key Concepts...');
      const conceptsPrompt = buildKeyConceptsPrompt(moduleDescription, moduleName, conceptName);
      sheet.getRange(row, 4).setValue(callGeminiApi_(conceptsPrompt));
  }
  if (!sheet.getRange(row, 8).getValue()) {
      SpreadsheetApp.getActiveSpreadsheet().toast('Generating Slide Specifications...');
      const specsPrompt = buildSlideSpecsPrompt(moduleDescription, sheet.getRange(row, 4).getValue(), moduleName, conceptName);
      sheet.getRange(row, 8).setValue(callGeminiApi_(specsPrompt));
  }
  const slideSpecs = sheet.getRange(row, 8).getValue();
  
  try {
    SpreadsheetApp.getActiveSpreadsheet().toast(`Generating Scenarios for "${moduleName}".`);
    const scenariosPrompt = buildEnhancedScenariosPrompt_(moduleName, moduleDescription, slideSpecs);
    sheet.getRange(row, 5).setValue(callGeminiApi_(scenariosPrompt, 1.0));

    SpreadsheetApp.getActiveSpreadsheet().toast(`Generating Assessments for "${moduleName}".`);
    const assessmentsPrompt = buildEnhancedAssessmentsPrompt_(moduleName, moduleDescription, slideSpecs);
    sheet.getRange(row, 6).setValue(callGeminiApi_(assessmentsPrompt));

    SpreadsheetApp.getActiveSpreadsheet().toast(`Generating Downloadable Resources Doc with research...`);
    const downloadablePrompt = buildDownloadablePrompt(slideSpecs, moduleName, conceptName);
    const researchedContent = callGeminiApi_(downloadablePrompt, 0.7, true);
    const docUrl = createDownloadableDoc_(moduleSubfolder, conceptName, moduleName, researchedContent); 
    sheet.getRange(row, 7).setValue(docUrl);
  } catch (e) {
    SpreadsheetApp.getUi().alert(`Error generating suite: ${e.toString()}`);
    return;
  }
  
  // Initialise TTS sheet with sophisticated slide content
  seedTTSFromSpecs(conceptName, moduleName, slideSpecs);
  SpreadsheetApp.getActiveSpreadsheet().toast(`Successfully generated all resources for "${moduleName}".`);
}

function generateAbsorbLmsFile() {
  const { sheet, row, moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;

  const moduleSubfolder = getModuleSubfolder_(conceptName, moduleName);
  if (!moduleSubfolder) return;

  const slideSpecs = sheet.getRange(row, 8).getValue();
  const downloadableResourcesUrl = sheet.getRange(row, 7).getValue(); 
  
  if (!slideSpecs || !downloadableResourcesUrl) {
    return SpreadsheetApp.getUi().alert('Slide Specs (Col H) and Downloadable Resources (Col G) must be generated first.');
  }
  
  const absorbLmsPrompt = buildAbsorbLmsPrompt_(moduleName, slideSpecs, 'Note: Downloadable resources are provided in a separate document linked in the course.');
  const markdownContent = callGeminiApi_(absorbLmsPrompt);
  const docUrl = createGoogleDocFromMarkdown_(moduleSubfolder, conceptName, moduleName, markdownContent);
  sheet.getRange(row, 9).setValue(docUrl); // Link in Col I
  
  SpreadsheetApp.getActiveSpreadsheet().toast(`Successfully created Absorb LMS Doc for "${moduleName}".`);
}

function generateVoiceoverScripts() {
  const { sheet, row, moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;

  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  SpreadsheetApp.getActiveSpreadsheet().toast(`Generating voiceover scripts for "${moduleName}"...`);

  const slideSpecs = sheet.getRange(row, 8).getValue();
  if (!slideSpecs) {
    return ui.alert('Slide Specs (Column H) are required to generate voiceover scripts.');
  }

  const ttsSheet = ss.getSheetByName(`TTS-${conceptName}`);
  if (!ttsSheet) {
    return ui.alert(`Could not find the TTS sheet: "TTS-${conceptName}". Run "#3" first.`);
  }

  const slideData = parseSlideSpecs(slideSpecs);
  if (slideData.length === 0) {
    return ui.alert("Could not parse slide specifications. Please check the format in Column H.");
  }
  
  const ttsContent = [];
  try {
    for (let i = 0; i < slideData.length; i++) {
      const slide = slideData[i];
      const slideNumber = i + 1;
      const combinedText = `${slide.title}\n\n${slide.body.join('\n')}`;
      ss.toast(`Generating content for Slide ${slideNumber} of ${slideData.length}...`);
      
      const speakerNotesPrompt = buildSpeakerNotesPrompt(combinedText, moduleName, conceptName);
      const speakerNotes = callGeminiApi_(speakerNotesPrompt);
      
      const imagePromptRaw = buildImagePrompt(combinedText, moduleName, conceptName);
      const imagePromptResult = callGeminiApi_(imagePromptRaw);

      const alternateContentPrompt = buildAlternateSlideContentPrompt(combinedText, moduleName);
      const alternateContent = callGeminiApi_(alternateContentPrompt);

      const duration = estimateAudioDuration_(speakerNotes);
      
      ttsContent.push([
        moduleName, slideNumber, combinedText, speakerNotes, duration, '', '', 
        imagePromptResult, '', alternateContent
      ]);
      
      Utilities.sleep(1000); 
    }
  } catch (e) {
    return ui.alert(`An error occurred during content generation: ${e.toString()}`);
  }

  if (ttsContent.length > 0) {
    const firstEmptyRow = ttsSheet.getLastRow() + 1;
    ttsSheet.getRange(firstEmptyRow, 1, ttsContent.length, 10).setValues(ttsContent);
    ss.toast(`Successfully added content for ${ttsContent.length} slides to the TTS tab.`);
  }
}

function generateSlidesForSelectedModule() {
  const ui = SpreadsheetApp.getUi();
  const { sheet, row, moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;

  const ttsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(`TTS-${conceptName}`);
  if (!ttsSheet) {
    return ui.alert(`Cannot find the required TTS sheet: "TTS-${conceptName}". Please run "#6 Generate Voiceover Scripts" first.`);
  }

  const contentChoice = ui.alert('Slide Content Source', 'Which content do you want to use for the slides?\n\nYES = Standard Slide Content (Col C)\nNO = Alternate Slide Content (Col J)', ui.ButtonSet.YES_NO_CANCEL);
  if (contentChoice === ui.Button.CANCEL) {
    SpreadsheetApp.getActiveSpreadsheet().toast('Slide generation cancelled.');
    return;
  }
  const contentColumn = (contentChoice === ui.Button.YES) ? 3 : 10;
  const contentType = (contentChoice === ui.Button.YES) ? 'Standard' : 'Abbreviated';
  SpreadsheetApp.getActiveSpreadsheet().toast(`Generating slides using ${contentType} content...`);

  const slideData = [];
  const ttsValues = ttsSheet.getRange(2, 1, ttsSheet.getLastRow() - 1, contentColumn).getValues();
  for (const ttsRow of ttsValues) {
    if (String(ttsRow[0]).trim() === String(moduleName).trim()) {
      const slideContent = ttsRow[contentColumn - 1];
      const slideNumber = Number(ttsRow[1]);
      if (slideContent && slideNumber) {
        slideData.push({ content: slideContent, number: slideNumber });
      }
    }
  }
  
  slideData.sort((a, b) => a.number - b.number);
  const slideContents = slideData.map(slide => slide.content);

  if (slideContents.length === 0) {
    return ui.alert(`No content found for "${moduleName}" in Column ${contentColumn === 3 ? 'C' : 'J'}.`);
  }

  try {
    const moduleSubfolder = getModuleSubfolder_(conceptName, moduleName);
    if (!moduleSubfolder) return;

    const presentation = createDeckFromTemplate_(`${conceptName} — ${moduleName}`);
    buildSlidesFromContentArray_(presentation, slideContents);
    
    const file = DriveApp.getFileById(presentation.getId());
    moduleSubfolder.addFile(file);
    DriveApp.getRootFolder().removeFile(file);
    
    const url = file.getUrl();
    writeSlidesLinkToTTS_(conceptName, moduleName, url);
    
    ui.alert(`${contentType} Slides created:\n${url}\n(Link saved to TTS Column F)`);
  } catch (e) {
    ui.alert(`An error occurred during slide generation: ${e.toString()}`);
  }
}

// ===== Audio generation flows (kept, but hardened for idempotency + retries) =====

function generateAllAudioForModule() {
  const { moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;

  const ui = SpreadsheetApp.getUi();
  const moduleSubfolder = getModuleSubfolder_(conceptName, moduleName);
  if (!moduleSubfolder) return;
  
  const ttsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(`TTS-${conceptName}`);
  if (!ttsSheet) return ui.alert(`TTS sheet for "${conceptName}" not found.`);

  const regenerate = String(PropertiesService.getScriptProperties().getProperty('REGENERATE_TTS') || 'false').toLowerCase() === 'true';

  SpreadsheetApp.getActiveSpreadsheet().toast(`Starting audio generation for module: ${moduleName}.`);
  
  const lastRow = ttsSheet.getLastRow();
  if (lastRow < 2) return ui.alert('No TTS rows found.');

  const data = ttsSheet.getRange(2, 1, lastRow - 1, 9).getValues();
  let generatedCount = 0;

  const maxRetries = 3;
  const baseDelayMs = 1500;

  for (let i = 0; i < data.length; i++) {
    if (data[i][0] !== moduleName) continue; // Col A Module
    const slideNumber = data[i][1];          // Col B Slide #
    const textToSpeak = data[i][3];          // Col D Script (speaker notes)
    const existingUrl = data[i][6];          // Col G Audio URL
    const voiceName = data[i][8] || VOICE_NAME; // Col I Voice (fallback to constant)

    if (!textToSpeak) continue;

    if (existingUrl && !regenerate){
      // Skip if already has audio and not regenerating
      const prev = String(ttsSheet.getRange(i+2,9).getValue()||'');
      ttsSheet.getRange(i+2,9).setValue(prev ? `${prev}\nSkipped: already has audio` : 'Skipped: already has audio');
      continue;
    }

    // Retry loop
    let attempt = 0, ok = false, audioUrl = '', errorMsg = '';
    while (attempt < maxRetries && !ok){
      try {
        // Your existing generator; AUSTRALIAN_PROMPT + temperature honoured downstream
        audioUrl = generateAudioForSlide_(moduleSubfolder, moduleName, slideNumber, textToSpeak, voiceName);
        ok = Boolean(audioUrl);
      } catch(e){
        errorMsg = e.message || String(e);
      }
      if (!ok){ Utilities.sleep(baseDelayMs * Math.pow(2, attempt)); }
      attempt++;
    }

    if (ok){
      ttsSheet.getRange(i + 2, 7).setValue(audioUrl); // Col G URL
      generatedCount++;
      SpreadsheetApp.getActiveSpreadsheet().toast(`Generated audio for Slide ${slideNumber}...`);
    } else {
      SpreadsheetApp.getActiveSpreadsheet().toast(`TTS failed for Slide ${slideNumber}: ${errorMsg}`);
    }
  }

  SpreadsheetApp.getActiveSpreadsheet().toast(`Audio generation complete for ${moduleName}. ${generatedCount} files created.`);
}

function cleanModuleAudioFiles() {
  const { moduleName, conceptName } = getActiveModuleInfo_('Module-Resources');
  if (!moduleName) return;
  
  const ui = SpreadsheetApp.getUi();
  const response = ui.alert('Confirm Deletion', `This will trash all .wav audio files for the module "${moduleName}". Are you sure?`, ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) return;

  const targetFolder = getModuleSubfolder_(conceptName, moduleName);
  if (!targetFolder) return;

  const files = targetFolder.getFilesByType(MimeType.WAV);
  let count = 0;
  while (files.hasNext()) {
    files.next().setTrashed(true);
    count++;
  }
  
  const ttsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(`TTS-${conceptName}`);
  if(ttsSheet){
      const data = ttsSheet.getRange("A2:G").getValues();
      for(let i=0; i < data.length; i++){
          if(data[i][0] === moduleName){
              ttsSheet.getRange(i+2, 7).clearContent(); // clear URL col G
          }
      }
  }
  
  ui.alert(`Trashed ${count} audio files for "${moduleName}" and cleared links from the sheet.`);
}

function archiveCourse() {
  const ui = SpreadsheetApp.getUi();
  const mappingSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Mapping');
  if (!mappingSheet) return ui.alert('Mapping sheet not found.');
  
  const row = mappingSheet.getActiveCell().getRow();
  if (row < 2) return ui.alert('Select a course row to archive.');
  
  const courseName = mappingSheet.getRange(row, 1).getValue();
  const courseFolderUrl = mappingSheet.getRange(row, 20).getValue(); // Column T
  if (!courseName || !courseFolderUrl) return ui.alert('Cannot archive: course name or folder not found.');

  const response = ui.alert('Confirm Archival', `This will move the content tabs for "${courseName}" into a new backup spreadsheet inside your project folder and then remove this row from the Mapping tab. This action cannot be undone. Proceed?`, ui.ButtonSet.YES_NO);
  if (response !== ui.Button.YES) return;

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const courseFolderId = extractIdFromUrl_(courseFolderUrl);
    const courseFolder   = DriveApp.getFolderById(courseFolderId);

    const backupSpreadsheet = SpreadsheetApp.create(`${courseName} - Course Content Backup`);
    const backupFile = DriveApp.getFileById(backupSpreadsheet.getId());
    courseFolder.addFile(backupFile);
    DriveApp.getRootFolder().removeFile(backupFile);

    const resourcesSheet = ss.getSheetByName(`Module-Resources-${courseName}`);
    const ttsSheet = ss.getSheetByName(`TTS-${courseName}`);
    
    if (resourcesSheet) resourcesSheet.copyTo(backupSpreadsheet);
    if (ttsSheet) ttsSheet.copyTo(backupSpreadsheet);
    
    const placeholderSheet = backupSpreadsheet.getSheetByName('Sheet1');
    if (placeholderSheet) backupSpreadsheet.deleteSheet(placeholderSheet);

    if (resourcesSheet) ss.deleteSheet(resourcesSheet);
    if (ttsSheet) ss.deleteSheet(ttsSheet);

    mappingSheet.deleteRow(row);

    ui.alert('Archival Complete', `The content for "${courseName}" has been backed up. It is now safe to move the project folder "${courseName}" out of the main tool folder if you wish.`, ui.ButtonSet.OK);
  } catch (e) {
    ui.alert(`Archival failed: ${e.toString()}`);
  }
}

// ===== Sophisticated script generation (unchanged logic, AU context retained) =====

function populateTTSWithAIGeneratedVoiceovers(){
  const mres = SpreadsheetApp.getActiveSheet();
  if (!mres.getName().startsWith('Module-Resources-')) {
    SpreadsheetApp.getUi().alert('Run this on a Module-Resources-{Concept} tab (select a module row).');
    return;
  }
  const concept = mres.getName().replace(/^Module-Resources-/, '');
  const row = mres.getActiveRange().getRow();
  const moduleName = mres.getRange(row, 1).getValue();
  const norm = s => String(s||'').replace(/\s+/g,' ').trim();

  if (!norm(moduleName)) { 
    SpreadsheetApp.getUi().alert('No Module Name in Column A for the selected row.'); 
    return; 
  }

  const tts = ensureTTSSheet(concept);
  const last = tts.getLastRow();
  const slideContents = [];
  const rows = [];
  
  for (let r=2; r<=last; r++){
    if (norm(tts.getRange(r,1).getValue()) === norm(moduleName)) {
      const slideContent = tts.getRange(r, 3).getValue(); // Column C: Slide Content
      const slideNumber = Number(tts.getRange(r,2).getValue()) || r;
      const slideTitle = String(slideContent || '').split('\n')[0].replace(/^#+\s*/, '').trim();
      
      if (slideContent && String(slideContent).trim()) {
        slideContents.push({
          title: slideTitle,
          content: String(slideContent).trim(),
          slideNumber: slideNumber
        });
        rows.push({ r, n: slideNumber });
      }
    }
  }
  
  if (!slideContents.length) { 
    SpreadsheetApp.getUi().alert('No slide content found in TTS tab Column C for this module. Run "Generate Full Module Resource Suite" first.'); 
    return; 
  }
  
  slideContents.sort((a,b) => a.slideNumber - b.slideNumber);
  rows.sort((a,b) => a.n - b.n);

  const prompts = slideContents.map((slide, i) => {
    const lines = slide.content.split('\n').filter(line => line.trim());
    const title = lines[0].replace(/^#+\s*/, '').trim();
    const bodyLines = lines.slice(1).filter(line => 
      line.trim() && 
      !line.match(/^#+\s/) &&
      !line.match(/^\s*[-*•]\s*$/)
    );
    
    const bodyContent = bodyLines
      .map(line => line.replace(/^\s*[-*•]\s*/, '').trim())
      .filter(line => line.length > 0)
      .join('. ');
    
    return brandHeader_() + `
Create a sophisticated voiceover script for an executive-level healthcare education presentation. This is slide ${i+1} of ${slideContents.length} in the "${concept}" professional development module.

SLIDE TITLE: ${title}
SLIDE CONTENT TO ENHANCE: ${bodyContent}

[... requirements unchanged for brevity in this paste, keep your original block here verbatim ...]`;
  });

  if (!prompts.length){ 
    SpreadsheetApp.getUi().alert('No prompts built for this module.'); 
    return; 
  }

  const scripts = [];
  const durations = [];
  
  trackProgress('Enhanced Voiceover Generation', 0, prompts.length, 'Generating executive-level voiceover scripts...');
  
  for (let i=0; i<prompts.length; i++){
    try{
      trackProgress('Enhanced Voiceover Generation', i + 1, prompts.length, `Generating sophisticated script for slide ${i + 1}...`);
      const script = au(callGeminiWithRetry(prompts[i], 1500));
      const trimmed = String(script||'').trim();
      if (!trimmed) throw new Error('Empty response from model');
      scripts.push([trimmed]);
      const words = trimmed.split(/\s+/).filter(Boolean).length;
      const mins = Math.max(0.5, Math.round((words / 160) * 10) / 10);
      durations.push([`${mins} min`]);
    }catch(e){
      scripts.push([`[[ERROR: ${e.message}]]`]);
      durations.push(['']);
    }
    Utilities.sleep(8000);
  }

  if (rows.length < scripts.length){
    SpreadsheetApp.getUi().alert(
      `Parsed ${scripts.length} slides but found only ${rows.length} TTS rows for "${moduleName}". Re-run "Resync: Seed TTS rows…" and try again.`
    );
    return;
  }
  const start = rows[0].r;
  tts.getRange(start, 4, scripts.length, 1).setValues(scripts);   // Col D: speaker notes
  tts.getRange(start, 5, durations.length, 1).setValues(durations); // Col E

  const wrote = scripts.filter(x => String(x[0]||'').trim() && !/^\[\[ERROR:/.test(x[0])).length;
  if (!wrote){
    SpreadsheetApp.getUi().alert('No voiceover text was generated. Check slide content in TTS tab Column C and try again.');
    return;
  }
  SpreadsheetApp.getUi().alert(`Generated ${wrote} executive-level voiceover script(s) for "${moduleName}" using enhanced slide content from TTS tab.`);
}

function generateImagePromptsForTab(){
  const sh = SpreadsheetApp.getActiveSheet();
  if (!sh.getName().startsWith('Module-Resources-')) return SpreadsheetApp.getUi().alert('Run on Module-Resources-{Concept}.');
  const concept = sh.getName().replace('Module-Resources-','');
  let img = SpreadsheetApp.getActive().getSheetByName(`IMG-${concept}`);
  if (!img){ img=SpreadsheetApp.getActive().insertSheet(`IMG-${concept}`); img.getRange(1,1,1,4).setValues([[ 'Module Name','Slide #','Prompt (AU context)','Drive File ID (optional)' ]]).setFontWeight('bold'); }
  const last = sh.getLastRow();
  for (let r=2; r<=last; r++){
    const module = sh.getRange(r,1).getValue();
    const spec = sh.getRange(r,8).getValue();
    if (!module || !spec) continue;
    const slides = parseSlideSpecs(spec);
    slides.forEach(function(s,i){
      const phrases = s.body.map(function(l){ return String(l).replace(/^\s*[-*•]\s*/,'').trim(); }).filter(Boolean).slice(0,6).join('; ');
      const p = `AU healthcare visual for "${s.title}". Emphasise clinical context; accessible contrast; no baked-in text; culturally safe. Ideas: ${phrases}.`;
      img.appendRow([module, i+1, p, '']);
    });
  }
  SpreadsheetApp.getUi().alert('Image prompts written.');
}

function exportTTSForSelectedModuleToCSV(){
  const sh = SpreadsheetApp.getActiveSheet();
  let concept, module;
  
  if (sh.getName().startsWith('TTS-')) {
    concept = sh.getName().replace('TTS-','');
    const row = sh.getActiveRange().getRow();
    module = sh.getRange(row,1).getValue();
  } else if (sh.getName().startsWith('Module-Resources-')) {
    concept = sh.getName().replace('Module-Resources-','');
    const row = sh.getActiveRange().getRow();
    module = sh.getRange(row,1).getValue();
  } else {
    return SpreadsheetApp.getUi().alert('Run on TTS-{Concept} or Module-Resources-{Concept} tab.');
  }
  
  if (!module) return SpreadsheetApp.getUi().alert('Select a row with a module name.');
  const url = exportTTSModuleToCSV_(concept, module);
  SpreadsheetApp.getUi().alert('CSV saved:\n' + url);
}

function exportTTSForAllModulesToCSV(){
  const sh = SpreadsheetApp.getActiveSheet();
  let concept;
  
  if (sh.getName().startsWith('TTS-')) {
    concept = sh.getName().replace('TTS-','');
  } else if (sh.getName().startsWith('Module-Resources-')) {
    concept = sh.getName().replace('Module-Resources-','');
  } else {
    return SpreadsheetApp.getUi().alert('Run on TTS-{Concept} or Module-Resources-{Concept} tab.');
  }
  
  const tts = ensureTTSSheet(concept);
  const processedModules = new Set();
  let count = 0, lastUrl = '';
  
  for (let r = 2; r <= tts.getLastRow(); r++) {
    const module = tts.getRange(r, 1).getValue();
    if (module && !processedModules.has(module)) {
      lastUrl = exportTTSModuleToCSV_(concept, module);
      processedModules.add(module);
      count++;
      Utilities.sleep(120);
    }
  }
  
  SpreadsheetApp.getUi().alert(`CSV files created for ${count} modules. Last file:\n${lastUrl}`);
}

function generateGeminiAudioForSelectedModule(){
  const sh = SpreadsheetApp.getActiveSheet();
  let concept, module;
  
  if (sh.getName().startsWith('TTS-')) {
    concept = sh.getName().replace('TTS-','');
    const row = sh.getActiveRange().getRow();
    module = sh.getRange(row,1).getValue();
  } else if (sh.getName().startsWith('Module-Resources-')) {
    concept = sh.getName().replace('Module-Resources-','');
    const row = sh.getActiveRange().getRow();
    module = sh.getRange(row,1).getValue();
  } else {
    return SpreadsheetApp.getUi().alert('Run on TTS-{Concept} or Module-Resources-{Concept} tab.');
  }
  
  if (!module) return SpreadsheetApp.getUi().alert('Select a row with a module name.');
  return generateGeminiAudioForModule_(concept, module);
}

function generateGeminiAudioForAllModules(){
  const sh = SpreadsheetApp.getActiveSheet();
  let concept;
  
  if (sh.getName().startsWith('TTS-')) {
    concept = sh.getName().replace('TTS-','');
  } else if (sh.getName().startsWith('Module-Resources-')) {
    concept = sh.getName().replace('Module-Resources-','');
  } else {
    return SpreadsheetApp.getUi().alert('Run on TTS-{Concept} or Module-Resources-{Concept} tab.');
  }
  
  const tts = ensureTTSSheet(concept);
  const processedModules = new Set();
  
  for (let r = 2; r <= tts.getLastRow(); r++) {
    const module = tts.getRange(r, 1).getValue();
    if (module && !processedModules.has(module)) {
      generateGeminiAudioForModule_(concept, module);
      processedModules.add(module);
      Utilities.sleep(120);
    }
  }
  
  SpreadsheetApp.getUi().alert(`Audio generated for ${processedModules.size} modules.`);
}

function purgeTtsAudioWithConfirm(){
  const ui = SpreadsheetApp.getUi();
  const resp = ui.alert('Purge audio files?', 'This will move MP3/WAV files in the working folder to Trash. Continue?', ui.ButtonSet.YES_NO);
  if (resp !== ui.Button.YES) return;
  purgeTtsAudioInWorkingFolder();
}

function purgeTtsAudioInWorkingFolder(conceptFilter){
  const folder = DriveApp.getFolderById(CFG.DRIVE_FOLDER_ID);
  const it = folder.getFiles();
  const re = conceptFilter
    ? new RegExp('^' + String(conceptFilter).replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s—\\s.*\\.(mp3|wav)$','i')
    : /\.(mp3|wav)$/i;

  let removed = 0, kept = 0;
  while (it.hasNext()){
    const f = it.next();
    const name = f.getName();
    const mime = String(f.getMimeType()||'').toLowerCase();
    if (re.test(name) || mime.startsWith('audio/')){
      try { f.setTrashed(true); removed++; } catch(_) { kept++; }
    } else {
      kept++;
    }
  }
  SpreadsheetApp.getUi().alert(`Audio clean-out complete.\nRemoved: ${removed}\nKept: ${kept}\nFolder: ${folder.getName()}`);
}

function exportTTSModuleToCSV_(concept, module){
  const tts = ensureTTSSheet(concept);
  const rows = [];
  for (let r=2; r<=tts.getLastRow(); r++){
    if (String(tts.getRange(r,1).getValue()).trim() !== String(module).trim()) continue;
    const slideNo = tts.getRange(r,2).getValue();
    const script  = tts.getRange(r,3).getValue();
    rows.push([module, slideNo, script, VOICE_NAME, SPEECH_TEMPERATURE, AUSTRALIAN_PROMPT]);
  }
  if (!rows.length) throw new Error('No TTS rows found for module: ' + module);

  const csvLines = [['Module Name','Slide Number','Script','Voice','Temperature','Voice Direction']]
    .concat(rows)
    .map(cols => cols.map(v => {
      const s = (v==null ? '' : String(v)).replace(/"/g, '""');
      return '"' + s + '"';
    }).join(','));

  const blob = Utilities.newBlob(csvLines.join('\n'), 'text/csv', `${concept} — ${module} — TTS.csv`);
  const file = DriveApp.getFolderById(CFG.DRIVE_FOLDER_ID).createFile(blob);
  return file.getUrl();
}

// === Hardened: idempotent + retry + AUSTRALIAN_PROMPT + temperature preserved ===
function generateGeminiAudioForModule_(concept, module){
  const tts = ensureTTSSheet(concept);
  const folder = DriveApp.getFolderById(CFG.DRIVE_FOLDER_ID);
  const regenerate = String(PropertiesService.getScriptProperties().getProperty('REGENERATE_TTS') || 'false').toLowerCase() === 'true';

  let count=0;
  const maxRetries = 3;
  const baseDelayMs = 1500;

  for (let r=2;r<=tts.getLastRow();r++){
    const mod = String(tts.getRange(r,1).getValue()).trim();
    if (mod !== String(module).trim()) continue;

    const slideNo  = tts.getRange(r,2).getValue();
    const script   = tts.getRange(r,4).getValue();  // Column D: speaker notes
    const existing = tts.getRange(r,7).getValue();  // Column G: Audio URL

    if (!script) continue;
    if (existing && !regenerate){
      // Note the skip in Col J (Notes) and continue
      const prevNote = String(tts.getRange(r,10).getValue()||'');
      tts.getRange(r,10).setValue(prevNote ? `${prevNote}\nSkipped: already has audio` : 'Skipped: already has audio');
      continue;
    }

    let attempt = 0, ok = false, fileUrl = '', lastErr = '';
    while (attempt < maxRetries && !ok){
      try{
        const audioBlob = callGeminiTTS_(AUSTRALIAN_PROMPT + ' ' + script, VOICE_NAME, SPEECH_TEMPERATURE);
        if (!audioBlob) { lastErr = 'TTS returned empty audio'; }
        else {
          // Overwrite behaviour if regenerating: delete older files for this slide in the working folder
          if (regenerate){
            const it = folder.getFilesByName(`${concept} — ${module} — Slide ${slideNo}.wav`);
            while (it.hasNext()){ try { it.next().setTrashed(true); } catch(_) {} }
          }
          const name = `${concept} — ${module} — Slide ${slideNo}.wav`;
          const file = folder.createFile(audioBlob.setName(name));
          fileUrl = file.getUrl();
          ok = true;
        }
      }catch(e){
        lastErr = e.message || String(e);
      }
      if (!ok){ Utilities.sleep(baseDelayMs * Math.pow(2, attempt)); }
      attempt++;
    }

    if (ok){
      tts.getRange(r,7).setValue(fileUrl); // URL
      const prevNote = String(tts.getRange(r,10).getValue()||'');
      tts.getRange(r,10).setValue(prevNote ? `${prevNote}\nGenerated OK` : 'Generated OK');
      count++;
    } else {
      const prevNote = String(tts.getRange(r,10).getValue()||'');
      tts.getRange(r,10).setValue(prevNote ? `${prevNote}\nERROR: ${lastErr}` : `ERROR: ${lastErr}`);
    }
  }

  SpreadsheetApp.getUi().alert(`Audio generation complete for "${module}". Files created: ${count}`);
}

// ==== F) Helper Functions & Misc ====

// ---------- Formatting helpers ----------
function safeClearTextStyle(el){
  try { el.getTextStyle().clear(); } catch(_) {}
}
function safeClearRangeStyle(rg){
  try { rg.clearFormat(); } catch(_) {}
}

function formatVancouverReferences_(sources){
  // De-duplicate by driveId/url/title
  const seen = new Set();
  const items = [];
  for (const s of (sources || [])){
    const key = (s.driveId || s.url || s.title || s.label || '').toLowerCase();
    if (!key || seen.has(key)) continue;
    seen.add(key);

    let line = '';
    if (s.type === 'web'){
      // Org/Title. [Internet]. [cited YYYY Mon DD]. Available from: URL
      const org = (s.title && s.title.length > 6) ? s.title : 'Website';
      const date = Utilities.formatDate(new Date(), Session.getScriptTimeZone(), 'yyyy MMM dd');
      line = `${org}. ${s.title || s.url} [Internet]. [cited ${date}]. Available from: ${s.url}`;
    } else if (s.type === 'drive-file'){
      // File name as Title; use Drive as publisher.
      const year = (new Date()).getFullYear();
      line = `${s.title || s.label}. Google Drive; ${year}.`;
    } else if (s.type === 'drive-folder'){
      const year = (new Date()).getFullYear();
      line = `${s.title || s.label}. Google Drive folder; ${year}.`;
    } else {
      line = `${s.title || s.label}.`;
    }
    items.push(line);
  }
  if (!items.length) return '';
  return items.map((l,i)=>`${i+1}. ${l}`).join('\n');
}

/**
 * Normalise and prettify content for professional docs.
 */
function formatDocumentContent_(txt){
  let t = String(txt||'')
    .replace(/\r/g,'')
    .replace(/[ \t]+\n/g,'\n')
    .replace(/\n{3,}/g,'\n\n')
    .trim();

  // Light touch: ensure bullet-like lines are bullets in target surfaces
  t = t.replace(/^\s*[-*•]\s+/gm, '• ');
  return t;
}

/**
 * Create a polished Google Doc and write content.
 */
function createSophisticatedContentDoc_(parentFolder, title, content){
  const doc = DocumentApp.create(title);
  DriveApp.getFileById(doc.getId()).moveTo(parentFolder);
  const body = doc.getBody();
  body.clear();
  body.appendParagraph(title).setHeading(DocumentApp.ParagraphHeading.HEADING1);
  body.appendParagraph('\n');
  const formatted = formatDocumentContent_(content);
  formatted.split('\n\n').forEach(block=>{
    if (/^•\s/.test(block)){
      const lines = block.split('\n').map(x=>x.replace(/^•\s/,'').trim()).filter(Boolean);
      const list = body.appendListItem(lines.shift()||'').setGlyphType(DocumentApp.GlyphType.BULLET);
      lines.forEach(l => body.appendListItem(l).setGlyphType(DocumentApp.GlyphType.BULLET));
    } else {
      body.appendParagraph(block);
    }
  });
  return doc.getId();
}

// ---------- Audio / TTS helpers ----------
/**
 * If Gemini TTS returns PCM L16 bytes, wrap into a proper WAV.
 * If it returns audio/wav already, just return that blob.
 */
function convertL16ToWav_(pcmBlob, sampleRateHz){
  const bytes = pcmBlob.getBytes();
  const numChannels = 1;
  const blockAlign = numChannels * 2;
  const byteRate = sampleRateHz * blockAlign;
  const dataSize = bytes.length;

  const buffer = Utilities.newBlob('', 'audio/wav', 'out.wav').getBytes();
  function push32(arr, v){ arr.push(v & 255, (v>>8)&255, (v>>16)&255, (v>>24)&255); }
  function push16(arr, v){ arr.push(v & 255, (v>>8)&255); }

  const header = [];
  // RIFF header
  header.push(82,73,70,70);                 // 'RIFF'
  push32(header, 36 + dataSize);
  header.push(87,65,86,69);                 // 'WAVE'
  // fmt subchunk
  header.push(102,109,116,32);              // 'fmt '
  push32(header, 16);                       // PCM
  push16(header, 1);                        // audio format = PCM
  push16(header, numChannels);
  push32(header, sampleRateHz);
  push32(header, byteRate);
  push16(header, blockAlign);
  push16(header, 16);                       // bitsPerSample
  // data subchunk
  header.push(100,97,116,97);               // 'data'
  push32(header, dataSize);

  const wav = Utilities.newBlob(header.concat(Array.prototype.slice.call(bytes)), 'audio/wav', 'tts.wav');
  return wav;
}

/**
 * Turn a slide (title/body) into a script with voice and audience in mind.
 * (For seeding TTS sheets; not the actual audio synthesis call.)
 */
function generateTTSScript(slide, concept, moduleName){
  const title = String(slide.title||'').trim();
  const body = (slide.body||[]).map(b => b.replace(/^\s*[-*•]\s*/, '').trim()).filter(Boolean);
  const audience = getTargetAudience(concept, moduleName);

  // Crisp voiceover paragraph oriented to executives
  const lines = [];
  lines.push(`${title}.`);
  if (body.length){
    lines.push(body.join('. ') + '.');
  }
  lines.push(`For ${audience} in Australia, focus on clarity, brevity, and actionable insight.`);
  return lines.join(' ');
}

/**
 * Build a scene description for image generation (prompt only).
 */
function generateImagePrompt(content, concept, moduleName){
  const topic = (moduleName || concept || 'topic').trim();
  return [
    `Clean, modern illustration for executive education on "${topic}".`,
    `Neutral background, high contrast, clear focal iconography.`,
    `Accessible design suitable for professional slides, uncluttered composition.`,
    `Avoid text in the image; no logos.`
  ].join(' ');
}

/**
 * Simple audience resolver – can be extended per concept.
 */
function getTargetAudience(concept, moduleName){
  return 'senior healthcare and business leaders';
}

/**
 * Enrich slide content for TTS script (alt pathway).
 */
function populateAlternateSlideContent(slide, concept, moduleName){
  const base = generateTTSScript(slide, concept, moduleName);
  // Subtle tightening
  return base.replace(/\s{2,}/g,' ').trim();
}

function removeBulletsPreserveFormatting(text){
  return String(text||'').split('\n').map(l => l.replace(/^\s*[-*•]\s*/,'')).join('\n');
}

/** Build a slightly more slide-aware image prompt from the structured slide */
function generateImagePromptForSlide(slide, concept, moduleName){
  const content = `${slide.title}\n${(slide.body||[]).join('\n')}`;
  return generateImagePrompt(content, concept, moduleName);
}

/**
 * Pre-check before audio generation – ensures sheet and columns exist.
 */
function ttsPreflightCheck(sh){
  const headers = sh.getRange(1,1,1,10).getValues()[0];
  const required = ['Module','Slide #','Script','Image Prompt','Alt Text','Voice','Backup Image Prompt','Audio File Id','Audio URL','Notes'];
  const missing = required.filter((h,i)=> String(headers[i]||'').trim() !== h);
  if (missing.length){
    sh.getRange(1,1,1,10).setValues([required]);
  }
}

/**
 * Create a new deck from a template and return the new presentation ID.
 */
function createDeckFromTemplate_(templateId, parentFolder, title){
  const templFile = DriveApp.getFileById(templateId);
  const newFile = templFile.makeCopy(title, parentFolder);
  return newFile.getId();
}

/**
 * Given an array of slide objects [{title, body:[]}] write into Slides.
 */
function buildSlidesFromContentArray_(presentationId, slides){
  const deck = SlidesApp.openById(presentationId);
  const master = deck.getSlides()[0];
  // Simple approach: duplicate first slide as a template
  for (let i = 0; i < slides.length; i++){
    const s = i === 0 ? master : master.duplicate();
    fillSlide_(s, slides[i]);
  }
}

/** Link the deck back to the TTS sheet */
function writeSlidesLinkToTTS_(ttsSheet, presentationId){
  const url = 'https://docs.google.com/presentation/d/' + presentationId + '/edit';
  ttsSheet.getRange(1,12).setValue('Slides URL'); // L1 marker (optional)
  ttsSheet.getRange(2,12).setValue(url);
}

/** Put title + bullet body into a slide */
function fillSlide_(slide, obj){
  const tShape = findShape_(slide, 'TITLE') || slide.getPageElements()[0];
  const bShape = findShape_(slide, 'BODY') || slide.getPageElements()[1];

  if (tShape && tShape.asShape){
    const tText = tShape.asShape().getText();
    safeClearTextStyle(tText);
    tText.setText(obj.title || 'Slide');
  }
  if (bShape && bShape.asShape){
    const bText = bShape.asShape().getText();
    safeClearTextStyle(bText);
    const bullets = (obj.body||[]).filter(Boolean);
    if (bullets.length){
      bText.setText(bullets[0]);
      for (let i = 1; i < bullets.length; i++){
        bText.appendParagraph(bullets[i]);
      }
      bText.getListStyle().applyListPreset(SlidesApp.ListPreset.BULLETED_LIST);
    } else {
      bText.setText('');
    }
  }
}

/**
 * Find a shape by its placeholder type or partial description.
 * (Assumes your template labels title/body shapes or uses placeholders.)
 */
function findShape_(slide, kind){
  const els = slide.getPageElements();
  for (let i = 0; i < els.length; i++){
    const e = els[i];
    try{
      const shape = e.asShape();
      const txt = shape.getText().asString().toUpperCase();
      if (kind === 'TITLE' && /TITLE|HEADING/.test(txt)) return e;
      if (kind === 'BODY'  && /BODY|CONTENT|TEXT/.test(txt)) return e;
    } catch(_) {}
  }
  return null;
}

/**
 * Create a simplified, downloadable .docx by converting a Google Doc
 * (Drive handles the export).
 */
function createDownloadableDoc_(docId){
  const file = DriveApp.getFileById(docId);
  // Consumers can export via File > Download > Microsoft Word (.docx)
  return file.getUrl();
}

/** Create a Google Doc from Markdown-like input (basic parsing) */
function createGoogleDocFromMarkdown_(parentFolder, title, markdown){
  return createSophisticatedContentDoc_(parentFolder, title, markdown);
}

/** Basic duration estimator (160 wpm ~ 2.67 wps) */
function estimateAudioDuration_(text){
  const words = String(text||'').trim().split(/\s+/).filter(Boolean).length;
  return Math.round((words / 2.67)); // seconds
}

/**
 * Generate audio for a single slide row (expects columns A:J per TTS sheet schema).
 * NOTE: Keeps Gemini TTS usage. If API returns audio/wav, we persist as-is.
 */
function generateAudioForSlide_(rowValues, moduleFolder){
  const moduleName = rowValues[0];
  const slideNo = rowValues[1];
  const script = String(rowValues[2]||'').trim();
  const voice = String(rowValues[5]||'VOICE_NAME').trim();

  if (!script){
    return { ok:false, error:`Slide ${slideNo}: empty script` };
  }

  // ---- Gemini TTS call (example payload; adjust to your exact endpoint usage) ----
  const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key='
    + CFG.GEMINI_API_KEY;

  const body = {
    contents: [{ parts: [{ text: script }]}],
    audioConfig: { audioEncoding: 'LINEAR16', sampleRateHertz: 24000 }, // request PCM; service may return wav
    generationConfig: { responseMimeType: 'audio/wav' }, // prefer WAV if supported
    // You can embed voice hints in text prompt; left light-touch here per your preference.
  };

  const resp = UrlFetchApp.fetch(url, {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(body),
    muteHttpExceptions: true,
    timeout: 60000
  });
  if (resp.getResponseCode() !== 200){
    return { ok:false, error:`Gemini TTS error ${resp.getResponseCode()}: ${resp.getContentText().slice(0,180)}` };
  }

  const data = JSON.parse(resp.getContentText());
  const part = data?.candidates?.[0]?.content?.parts?.find(p => p.inlineData && p.inlineData.mimeType);
  if (!part){
    return { ok:false, error:'TTS: no audio content returned' };
  }

  let blob;
  const mime = String(part.inlineData.mimeType || '').toLowerCase();

  if (mime.includes('audio/wav')){
    blob = Utilities.newBlob(Utilities.base64Decode(part.inlineData.data), 'audio/wav', `Slide${slideNo}.wav`);
  } else if (mime.includes('pcm') || mime.includes('l16')){
    const pcm = Utilities.newBlob(Utilities.base64Decode(part.inlineData.data), 'application/octet-stream', 'pcm.raw');
    blob = convertL16ToWav_(pcm, 24000);
    blob.setName(`Slide${slideNo}.wav`);
  } else if (mime.includes('audio/mpeg') || mime.includes('mp3')){
    blob = Utilities.newBlob(Utilities.base64Decode(part.inlineData.data), 'audio/mpeg', `Slide${slideNo}.mp3`);
  } else {
    return { ok:false, error:`Unexpected audio mimeType ${mime}` };
  }

  const file = moduleFolder.createFile(blob);
  return { ok:true, fileId:file.getId(), url:file.getUrl(), durationSec: estimateAudioDuration_(script) };
}

/**
 * Parse slide specs text into [{title, body:[]}] form.
 * Accepts headings like "# Slide 1: Title" or "Slide 1 — Title".
 */
function parseSlideSpecs_(specText){
  const src = String(specText||'').replace(/\r/g,'');
  const blocks = src.split(/\n(?=(?:#\s*)?Slide\s+\d+\s*(?:[:\-—]\s*|)\s)/i);

  const slides = [];
  for (let i=0; i<blocks.length; i++){
    const blk = blocks[i].trim();
    if (!blk) continue;

    // Title
    let title = 'Slide ' + (slides.length + 1);
    const m = blk.match(/^(?:#\s*)?Slide\s+\d+\s*(?:[:\-—]\s*|)\s*(.+)$/im);
    if (m) title = m[1].trim();

    // Body bullets: lines starting with -, *, •, or normal sentences
    const bodyLines = blk
      .replace(/^(?:#\s*)?Slide\s+\d+[^\n]*\n?/i, '')
      .split('\n')
      .map(l => l.trim())
      .filter(Boolean);

    const bullets = [];
    bodyLines.forEach(l=>{
      if (/^[-*•]\s+/.test(l)) bullets.push(l.replace(/^[-*•]\s+/, '').trim());
      else bullets.push(l);
    });

    slides.push({ title, body: bullets });
  }

  if (!slides.length) slides.push({ title:'Slide 1', body:[] });
  return slides;
}

const refs = formatVancouverReferences_(srcPack.sources || []);
if (refs){
  body.appendParagraph('\n\nReferences').setHeading(DocumentApp.ParagraphHeading.HEADING2);
  body.appendParagraph(refs);
}

